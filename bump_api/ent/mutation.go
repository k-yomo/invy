// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/k-yomo/bump/bump_api/ent/friendgroup"
	"github.com/k-yomo/bump/bump_api/ent/friendship"
	"github.com/k-yomo/bump/bump_api/ent/friendshiprequest"
	"github.com/k-yomo/bump/bump_api/ent/invitation"
	"github.com/k-yomo/bump/bump_api/ent/invitationacceptance"
	"github.com/k-yomo/bump/bump_api/ent/invitationdenial"
	"github.com/k-yomo/bump/bump_api/ent/invitationfriendgroup"
	"github.com/k-yomo/bump/bump_api/ent/invitationuser"
	"github.com/k-yomo/bump/bump_api/ent/predicate"
	"github.com/k-yomo/bump/bump_api/ent/user"
	"github.com/k-yomo/bump/bump_api/ent/userfriendgroup"
	"github.com/k-yomo/bump/bump_api/ent/usermute"
	"github.com/k-yomo/bump/bump_api/ent/userprofile"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFriendGroup           = "FriendGroup"
	TypeFriendship            = "Friendship"
	TypeFriendshipRequest     = "FriendshipRequest"
	TypeInvitation            = "Invitation"
	TypeInvitationAcceptance  = "InvitationAcceptance"
	TypeInvitationDenial      = "InvitationDenial"
	TypeInvitationFriendGroup = "InvitationFriendGroup"
	TypeInvitationUser        = "InvitationUser"
	TypeUser                  = "User"
	TypeUserFriendGroup       = "UserFriendGroup"
	TypeUserMute              = "UserMute"
	TypeUserProfile           = "UserProfile"
)

// FriendGroupMutation represents an operation that mutates the FriendGroup nodes in the graph.
type FriendGroupMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	name                            *string
	total_count                     *int
	addtotal_count                  *int
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	user                            *uuid.UUID
	cleareduser                     bool
	friend_users                    map[uuid.UUID]struct{}
	removedfriend_users             map[uuid.UUID]struct{}
	clearedfriend_users             bool
	invitation_friend_groups        map[uuid.UUID]struct{}
	removedinvitation_friend_groups map[uuid.UUID]struct{}
	clearedinvitation_friend_groups bool
	user_friend_groups              map[uuid.UUID]struct{}
	removeduser_friend_groups       map[uuid.UUID]struct{}
	cleareduser_friend_groups       bool
	done                            bool
	oldValue                        func(context.Context) (*FriendGroup, error)
	predicates                      []predicate.FriendGroup
}

var _ ent.Mutation = (*FriendGroupMutation)(nil)

// friendgroupOption allows management of the mutation configuration using functional options.
type friendgroupOption func(*FriendGroupMutation)

// newFriendGroupMutation creates new mutation for the FriendGroup entity.
func newFriendGroupMutation(c config, op Op, opts ...friendgroupOption) *FriendGroupMutation {
	m := &FriendGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendGroupID sets the ID field of the mutation.
func withFriendGroupID(id uuid.UUID) friendgroupOption {
	return func(m *FriendGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendGroup
		)
		m.oldValue = func(ctx context.Context) (*FriendGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendGroup sets the old FriendGroup of the mutation.
func withFriendGroup(node *FriendGroup) friendgroupOption {
	return func(m *FriendGroupMutation) {
		m.oldValue = func(context.Context) (*FriendGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendGroup entities.
func (m *FriendGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FriendGroupMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FriendGroupMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FriendGroupMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *FriendGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FriendGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FriendGroupMutation) ResetName() {
	m.name = nil
}

// SetTotalCount sets the "total_count" field.
func (m *FriendGroupMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *FriendGroupMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *FriendGroupMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *FriendGroupMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *FriendGroupMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FriendGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FriendGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FriendGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FriendGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FriendGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FriendGroupMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FriendGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddFriendUserIDs adds the "friend_users" edge to the User entity by ids.
func (m *FriendGroupMutation) AddFriendUserIDs(ids ...uuid.UUID) {
	if m.friend_users == nil {
		m.friend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_users[ids[i]] = struct{}{}
	}
}

// ClearFriendUsers clears the "friend_users" edge to the User entity.
func (m *FriendGroupMutation) ClearFriendUsers() {
	m.clearedfriend_users = true
}

// FriendUsersCleared reports if the "friend_users" edge to the User entity was cleared.
func (m *FriendGroupMutation) FriendUsersCleared() bool {
	return m.clearedfriend_users
}

// RemoveFriendUserIDs removes the "friend_users" edge to the User entity by IDs.
func (m *FriendGroupMutation) RemoveFriendUserIDs(ids ...uuid.UUID) {
	if m.removedfriend_users == nil {
		m.removedfriend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_users, ids[i])
		m.removedfriend_users[ids[i]] = struct{}{}
	}
}

// RemovedFriendUsers returns the removed IDs of the "friend_users" edge to the User entity.
func (m *FriendGroupMutation) RemovedFriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_users {
		ids = append(ids, id)
	}
	return
}

// FriendUsersIDs returns the "friend_users" edge IDs in the mutation.
func (m *FriendGroupMutation) FriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.friend_users {
		ids = append(ids, id)
	}
	return
}

// ResetFriendUsers resets all changes to the "friend_users" edge.
func (m *FriendGroupMutation) ResetFriendUsers() {
	m.friend_users = nil
	m.clearedfriend_users = false
	m.removedfriend_users = nil
}

// AddInvitationFriendGroupIDs adds the "invitation_friend_groups" edge to the InvitationFriendGroup entity by ids.
func (m *FriendGroupMutation) AddInvitationFriendGroupIDs(ids ...uuid.UUID) {
	if m.invitation_friend_groups == nil {
		m.invitation_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearInvitationFriendGroups clears the "invitation_friend_groups" edge to the InvitationFriendGroup entity.
func (m *FriendGroupMutation) ClearInvitationFriendGroups() {
	m.clearedinvitation_friend_groups = true
}

// InvitationFriendGroupsCleared reports if the "invitation_friend_groups" edge to the InvitationFriendGroup entity was cleared.
func (m *FriendGroupMutation) InvitationFriendGroupsCleared() bool {
	return m.clearedinvitation_friend_groups
}

// RemoveInvitationFriendGroupIDs removes the "invitation_friend_groups" edge to the InvitationFriendGroup entity by IDs.
func (m *FriendGroupMutation) RemoveInvitationFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedinvitation_friend_groups == nil {
		m.removedinvitation_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_friend_groups, ids[i])
		m.removedinvitation_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedInvitationFriendGroups returns the removed IDs of the "invitation_friend_groups" edge to the InvitationFriendGroup entity.
func (m *FriendGroupMutation) RemovedInvitationFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_friend_groups {
		ids = append(ids, id)
	}
	return
}

// InvitationFriendGroupsIDs returns the "invitation_friend_groups" edge IDs in the mutation.
func (m *FriendGroupMutation) InvitationFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationFriendGroups resets all changes to the "invitation_friend_groups" edge.
func (m *FriendGroupMutation) ResetInvitationFriendGroups() {
	m.invitation_friend_groups = nil
	m.clearedinvitation_friend_groups = false
	m.removedinvitation_friend_groups = nil
}

// AddUserFriendGroupIDs adds the "user_friend_groups" edge to the UserFriendGroup entity by ids.
func (m *FriendGroupMutation) AddUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.user_friend_groups == nil {
		m.user_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearUserFriendGroups clears the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *FriendGroupMutation) ClearUserFriendGroups() {
	m.cleareduser_friend_groups = true
}

// UserFriendGroupsCleared reports if the "user_friend_groups" edge to the UserFriendGroup entity was cleared.
func (m *FriendGroupMutation) UserFriendGroupsCleared() bool {
	return m.cleareduser_friend_groups
}

// RemoveUserFriendGroupIDs removes the "user_friend_groups" edge to the UserFriendGroup entity by IDs.
func (m *FriendGroupMutation) RemoveUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.removeduser_friend_groups == nil {
		m.removeduser_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_friend_groups, ids[i])
		m.removeduser_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserFriendGroups returns the removed IDs of the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *FriendGroupMutation) RemovedUserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_friend_groups {
		ids = append(ids, id)
	}
	return
}

// UserFriendGroupsIDs returns the "user_friend_groups" edge IDs in the mutation.
func (m *FriendGroupMutation) UserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.user_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserFriendGroups resets all changes to the "user_friend_groups" edge.
func (m *FriendGroupMutation) ResetUserFriendGroups() {
	m.user_friend_groups = nil
	m.cleareduser_friend_groups = false
	m.removeduser_friend_groups = nil
}

// Where appends a list predicates to the FriendGroupMutation builder.
func (m *FriendGroupMutation) Where(ps ...predicate.FriendGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FriendGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FriendGroup).
func (m *FriendGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, friendgroup.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, friendgroup.FieldName)
	}
	if m.total_count != nil {
		fields = append(fields, friendgroup.FieldTotalCount)
	}
	if m.created_at != nil {
		fields = append(fields, friendgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, friendgroup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendgroup.FieldUserID:
		return m.UserID()
	case friendgroup.FieldName:
		return m.Name()
	case friendgroup.FieldTotalCount:
		return m.TotalCount()
	case friendgroup.FieldCreatedAt:
		return m.CreatedAt()
	case friendgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendgroup.FieldUserID:
		return m.OldUserID(ctx)
	case friendgroup.FieldName:
		return m.OldName(ctx)
	case friendgroup.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case friendgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case friendgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendgroup.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case friendgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case friendgroup.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case friendgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case friendgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendGroupMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_count != nil {
		fields = append(fields, friendgroup.FieldTotalCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case friendgroup.FieldTotalCount:
		return m.AddedTotalCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case friendgroup.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	}
	return fmt.Errorf("unknown FriendGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FriendGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendGroupMutation) ResetField(name string) error {
	switch name {
	case friendgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case friendgroup.FieldName:
		m.ResetName()
		return nil
	case friendgroup.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case friendgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case friendgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, friendgroup.EdgeUser)
	}
	if m.friend_users != nil {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.invitation_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeInvitationFriendGroups)
	}
	if m.user_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case friendgroup.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.friend_users))
		for id := range m.friend_users {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeInvitationFriendGroups:
		ids := make([]ent.Value, 0, len(m.invitation_friend_groups))
		for id := range m.invitation_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.user_friend_groups))
		for id := range m.user_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfriend_users != nil {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.removedinvitation_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeInvitationFriendGroups)
	}
	if m.removeduser_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case friendgroup.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.removedfriend_users))
		for id := range m.removedfriend_users {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeInvitationFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedinvitation_friend_groups))
		for id := range m.removedinvitation_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_friend_groups))
		for id := range m.removeduser_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, friendgroup.EdgeUser)
	}
	if m.clearedfriend_users {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.clearedinvitation_friend_groups {
		edges = append(edges, friendgroup.EdgeInvitationFriendGroups)
	}
	if m.cleareduser_friend_groups {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case friendgroup.EdgeUser:
		return m.cleareduser
	case friendgroup.EdgeFriendUsers:
		return m.clearedfriend_users
	case friendgroup.EdgeInvitationFriendGroups:
		return m.clearedinvitation_friend_groups
	case friendgroup.EdgeUserFriendGroups:
		return m.cleareduser_friend_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendGroupMutation) ClearEdge(name string) error {
	switch name {
	case friendgroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendGroupMutation) ResetEdge(name string) error {
	switch name {
	case friendgroup.EdgeUser:
		m.ResetUser()
		return nil
	case friendgroup.EdgeFriendUsers:
		m.ResetFriendUsers()
		return nil
	case friendgroup.EdgeInvitationFriendGroups:
		m.ResetInvitationFriendGroups()
		return nil
	case friendgroup.EdgeUserFriendGroups:
		m.ResetUserFriendGroups()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup edge %s", name)
}

// FriendshipMutation represents an operation that mutates the Friendship nodes in the graph.
type FriendshipMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	friend_user        *uuid.UUID
	clearedfriend_user bool
	done               bool
	oldValue           func(context.Context) (*Friendship, error)
	predicates         []predicate.Friendship
}

var _ ent.Mutation = (*FriendshipMutation)(nil)

// friendshipOption allows management of the mutation configuration using functional options.
type friendshipOption func(*FriendshipMutation)

// newFriendshipMutation creates new mutation for the Friendship entity.
func newFriendshipMutation(c config, op Op, opts ...friendshipOption) *FriendshipMutation {
	m := &FriendshipMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipID sets the ID field of the mutation.
func withFriendshipID(id uuid.UUID) friendshipOption {
	return func(m *FriendshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Friendship
		)
		m.oldValue = func(ctx context.Context) (*Friendship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Friendship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendship sets the old Friendship of the mutation.
func withFriendship(node *Friendship) friendshipOption {
	return func(m *FriendshipMutation) {
		m.oldValue = func(context.Context) (*Friendship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Friendship entities.
func (m *FriendshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Friendship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FriendshipMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FriendshipMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FriendshipMutation) ResetUserID() {
	m.user = nil
}

// SetFriendUserID sets the "friend_user_id" field.
func (m *FriendshipMutation) SetFriendUserID(u uuid.UUID) {
	m.friend_user = &u
}

// FriendUserID returns the value of the "friend_user_id" field in the mutation.
func (m *FriendshipMutation) FriendUserID() (r uuid.UUID, exists bool) {
	v := m.friend_user
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendUserID returns the old "friend_user_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldFriendUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendUserID: %w", err)
	}
	return oldValue.FriendUserID, nil
}

// ResetFriendUserID resets all changes to the "friend_user_id" field.
func (m *FriendshipMutation) ResetFriendUserID() {
	m.friend_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FriendshipMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FriendshipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FriendshipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearFriendUser clears the "friend_user" edge to the User entity.
func (m *FriendshipMutation) ClearFriendUser() {
	m.clearedfriend_user = true
}

// FriendUserCleared reports if the "friend_user" edge to the User entity was cleared.
func (m *FriendshipMutation) FriendUserCleared() bool {
	return m.clearedfriend_user
}

// FriendUserIDs returns the "friend_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendUserID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) FriendUserIDs() (ids []uuid.UUID) {
	if id := m.friend_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriendUser resets all changes to the "friend_user" edge.
func (m *FriendshipMutation) ResetFriendUser() {
	m.friend_user = nil
	m.clearedfriend_user = false
}

// Where appends a list predicates to the FriendshipMutation builder.
func (m *FriendshipMutation) Where(ps ...predicate.Friendship) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FriendshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Friendship).
func (m *FriendshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, friendship.FieldUserID)
	}
	if m.friend_user != nil {
		fields = append(fields, friendship.FieldFriendUserID)
	}
	if m.created_at != nil {
		fields = append(fields, friendship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendship.FieldUserID:
		return m.UserID()
	case friendship.FieldFriendUserID:
		return m.FriendUserID()
	case friendship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendship.FieldUserID:
		return m.OldUserID(ctx)
	case friendship.FieldFriendUserID:
		return m.OldFriendUserID(ctx)
	case friendship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Friendship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendship.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case friendship.FieldFriendUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendUserID(v)
		return nil
	case friendship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Friendship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Friendship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipMutation) ResetField(name string) error {
	switch name {
	case friendship.FieldUserID:
		m.ResetUserID()
		return nil
	case friendship.FieldFriendUserID:
		m.ResetFriendUserID()
		return nil
	case friendship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.friend_user != nil {
		edges = append(edges, friendship.EdgeFriendUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendship.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case friendship.EdgeFriendUser:
		if id := m.friend_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.clearedfriend_user {
		edges = append(edges, friendship.EdgeFriendUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipMutation) EdgeCleared(name string) bool {
	switch name {
	case friendship.EdgeUser:
		return m.cleareduser
	case friendship.EdgeFriendUser:
		return m.clearedfriend_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipMutation) ClearEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ClearUser()
		return nil
	case friendship.EdgeFriendUser:
		m.ClearFriendUser()
		return nil
	}
	return fmt.Errorf("unknown Friendship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipMutation) ResetEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ResetUser()
		return nil
	case friendship.EdgeFriendUser:
		m.ResetFriendUser()
		return nil
	}
	return fmt.Errorf("unknown Friendship edge %s", name)
}

// FriendshipRequestMutation represents an operation that mutates the FriendshipRequest nodes in the graph.
type FriendshipRequestMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	from_users        *uuid.UUID
	clearedfrom_users bool
	to_users          *uuid.UUID
	clearedto_users   bool
	done              bool
	oldValue          func(context.Context) (*FriendshipRequest, error)
	predicates        []predicate.FriendshipRequest
}

var _ ent.Mutation = (*FriendshipRequestMutation)(nil)

// friendshiprequestOption allows management of the mutation configuration using functional options.
type friendshiprequestOption func(*FriendshipRequestMutation)

// newFriendshipRequestMutation creates new mutation for the FriendshipRequest entity.
func newFriendshipRequestMutation(c config, op Op, opts ...friendshiprequestOption) *FriendshipRequestMutation {
	m := &FriendshipRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendshipRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipRequestID sets the ID field of the mutation.
func withFriendshipRequestID(id uuid.UUID) friendshiprequestOption {
	return func(m *FriendshipRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendshipRequest
		)
		m.oldValue = func(ctx context.Context) (*FriendshipRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendshipRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendshipRequest sets the old FriendshipRequest of the mutation.
func withFriendshipRequest(node *FriendshipRequest) friendshiprequestOption {
	return func(m *FriendshipRequestMutation) {
		m.oldValue = func(context.Context) (*FriendshipRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendshipRequest entities.
func (m *FriendshipRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendshipRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromUserID sets the "from_user_id" field.
func (m *FriendshipRequestMutation) SetFromUserID(u uuid.UUID) {
	m.from_users = &u
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *FriendshipRequestMutation) FromUserID() (r uuid.UUID, exists bool) {
	v := m.from_users
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldFromUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *FriendshipRequestMutation) ResetFromUserID() {
	m.from_users = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *FriendshipRequestMutation) SetToUserID(u uuid.UUID) {
	m.to_users = &u
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *FriendshipRequestMutation) ToUserID() (r uuid.UUID, exists bool) {
	v := m.to_users
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldToUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *FriendshipRequestMutation) ResetToUserID() {
	m.to_users = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFromUsersID sets the "from_users" edge to the User entity by id.
func (m *FriendshipRequestMutation) SetFromUsersID(id uuid.UUID) {
	m.from_users = &id
}

// ClearFromUsers clears the "from_users" edge to the User entity.
func (m *FriendshipRequestMutation) ClearFromUsers() {
	m.clearedfrom_users = true
}

// FromUsersCleared reports if the "from_users" edge to the User entity was cleared.
func (m *FriendshipRequestMutation) FromUsersCleared() bool {
	return m.clearedfrom_users
}

// FromUsersID returns the "from_users" edge ID in the mutation.
func (m *FriendshipRequestMutation) FromUsersID() (id uuid.UUID, exists bool) {
	if m.from_users != nil {
		return *m.from_users, true
	}
	return
}

// FromUsersIDs returns the "from_users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromUsersID instead. It exists only for internal usage by the builders.
func (m *FriendshipRequestMutation) FromUsersIDs() (ids []uuid.UUID) {
	if id := m.from_users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromUsers resets all changes to the "from_users" edge.
func (m *FriendshipRequestMutation) ResetFromUsers() {
	m.from_users = nil
	m.clearedfrom_users = false
}

// SetToUsersID sets the "to_users" edge to the User entity by id.
func (m *FriendshipRequestMutation) SetToUsersID(id uuid.UUID) {
	m.to_users = &id
}

// ClearToUsers clears the "to_users" edge to the User entity.
func (m *FriendshipRequestMutation) ClearToUsers() {
	m.clearedto_users = true
}

// ToUsersCleared reports if the "to_users" edge to the User entity was cleared.
func (m *FriendshipRequestMutation) ToUsersCleared() bool {
	return m.clearedto_users
}

// ToUsersID returns the "to_users" edge ID in the mutation.
func (m *FriendshipRequestMutation) ToUsersID() (id uuid.UUID, exists bool) {
	if m.to_users != nil {
		return *m.to_users, true
	}
	return
}

// ToUsersIDs returns the "to_users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToUsersID instead. It exists only for internal usage by the builders.
func (m *FriendshipRequestMutation) ToUsersIDs() (ids []uuid.UUID) {
	if id := m.to_users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToUsers resets all changes to the "to_users" edge.
func (m *FriendshipRequestMutation) ResetToUsers() {
	m.to_users = nil
	m.clearedto_users = false
}

// Where appends a list predicates to the FriendshipRequestMutation builder.
func (m *FriendshipRequestMutation) Where(ps ...predicate.FriendshipRequest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FriendshipRequestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FriendshipRequest).
func (m *FriendshipRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipRequestMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.from_users != nil {
		fields = append(fields, friendshiprequest.FieldFromUserID)
	}
	if m.to_users != nil {
		fields = append(fields, friendshiprequest.FieldToUserID)
	}
	if m.created_at != nil {
		fields = append(fields, friendshiprequest.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendshiprequest.FieldFromUserID:
		return m.FromUserID()
	case friendshiprequest.FieldToUserID:
		return m.ToUserID()
	case friendshiprequest.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendshiprequest.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case friendshiprequest.FieldToUserID:
		return m.OldToUserID(ctx)
	case friendshiprequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendshiprequest.FieldFromUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case friendshiprequest.FieldToUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case friendshiprequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FriendshipRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FriendshipRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipRequestMutation) ResetField(name string) error {
	switch name {
	case friendshiprequest.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case friendshiprequest.FieldToUserID:
		m.ResetToUserID()
		return nil
	case friendshiprequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_users != nil {
		edges = append(edges, friendshiprequest.EdgeFromUsers)
	}
	if m.to_users != nil {
		edges = append(edges, friendshiprequest.EdgeToUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		if id := m.from_users; id != nil {
			return []ent.Value{*id}
		}
	case friendshiprequest.EdgeToUsers:
		if id := m.to_users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_users {
		edges = append(edges, friendshiprequest.EdgeFromUsers)
	}
	if m.clearedto_users {
		edges = append(edges, friendshiprequest.EdgeToUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		return m.clearedfrom_users
	case friendshiprequest.EdgeToUsers:
		return m.clearedto_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipRequestMutation) ClearEdge(name string) error {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		m.ClearFromUsers()
		return nil
	case friendshiprequest.EdgeToUsers:
		m.ClearToUsers()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipRequestMutation) ResetEdge(name string) error {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		m.ResetFromUsers()
		return nil
	case friendshiprequest.EdgeToUsers:
		m.ResetToUsers()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	location                        *string
	comment                         *string
	starts_at                       *time.Time
	expires_at                      *time.Time
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	user                            *uuid.UUID
	cleareduser                     bool
	invitation_users                map[uuid.UUID]struct{}
	removedinvitation_users         map[uuid.UUID]struct{}
	clearedinvitation_users         bool
	invitation_friend_groups        map[uuid.UUID]struct{}
	removedinvitation_friend_groups map[uuid.UUID]struct{}
	clearedinvitation_friend_groups bool
	invitation_acceptances          map[uuid.UUID]struct{}
	removedinvitation_acceptances   map[uuid.UUID]struct{}
	clearedinvitation_acceptances   bool
	invitation_denials              map[uuid.UUID]struct{}
	removedinvitation_denials       map[uuid.UUID]struct{}
	clearedinvitation_denials       bool
	done                            bool
	oldValue                        func(context.Context) (*Invitation, error)
	predicates                      []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id uuid.UUID) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invitation entities.
func (m *InvitationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationMutation) ResetUserID() {
	m.user = nil
}

// SetLocation sets the "location" field.
func (m *InvitationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *InvitationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *InvitationMutation) ResetLocation() {
	m.location = nil
}

// SetComment sets the "comment" field.
func (m *InvitationMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InvitationMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *InvitationMutation) ResetComment() {
	m.comment = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *InvitationMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *InvitationMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *InvitationMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *InvitationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *InvitationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *InvitationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddInvitationUserIDs adds the "invitation_users" edge to the InvitationUser entity by ids.
func (m *InvitationMutation) AddInvitationUserIDs(ids ...uuid.UUID) {
	if m.invitation_users == nil {
		m.invitation_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_users[ids[i]] = struct{}{}
	}
}

// ClearInvitationUsers clears the "invitation_users" edge to the InvitationUser entity.
func (m *InvitationMutation) ClearInvitationUsers() {
	m.clearedinvitation_users = true
}

// InvitationUsersCleared reports if the "invitation_users" edge to the InvitationUser entity was cleared.
func (m *InvitationMutation) InvitationUsersCleared() bool {
	return m.clearedinvitation_users
}

// RemoveInvitationUserIDs removes the "invitation_users" edge to the InvitationUser entity by IDs.
func (m *InvitationMutation) RemoveInvitationUserIDs(ids ...uuid.UUID) {
	if m.removedinvitation_users == nil {
		m.removedinvitation_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_users, ids[i])
		m.removedinvitation_users[ids[i]] = struct{}{}
	}
}

// RemovedInvitationUsers returns the removed IDs of the "invitation_users" edge to the InvitationUser entity.
func (m *InvitationMutation) RemovedInvitationUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_users {
		ids = append(ids, id)
	}
	return
}

// InvitationUsersIDs returns the "invitation_users" edge IDs in the mutation.
func (m *InvitationMutation) InvitationUsersIDs() (ids []uuid.UUID) {
	for id := range m.invitation_users {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationUsers resets all changes to the "invitation_users" edge.
func (m *InvitationMutation) ResetInvitationUsers() {
	m.invitation_users = nil
	m.clearedinvitation_users = false
	m.removedinvitation_users = nil
}

// AddInvitationFriendGroupIDs adds the "invitation_friend_groups" edge to the InvitationFriendGroup entity by ids.
func (m *InvitationMutation) AddInvitationFriendGroupIDs(ids ...uuid.UUID) {
	if m.invitation_friend_groups == nil {
		m.invitation_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearInvitationFriendGroups clears the "invitation_friend_groups" edge to the InvitationFriendGroup entity.
func (m *InvitationMutation) ClearInvitationFriendGroups() {
	m.clearedinvitation_friend_groups = true
}

// InvitationFriendGroupsCleared reports if the "invitation_friend_groups" edge to the InvitationFriendGroup entity was cleared.
func (m *InvitationMutation) InvitationFriendGroupsCleared() bool {
	return m.clearedinvitation_friend_groups
}

// RemoveInvitationFriendGroupIDs removes the "invitation_friend_groups" edge to the InvitationFriendGroup entity by IDs.
func (m *InvitationMutation) RemoveInvitationFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedinvitation_friend_groups == nil {
		m.removedinvitation_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_friend_groups, ids[i])
		m.removedinvitation_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedInvitationFriendGroups returns the removed IDs of the "invitation_friend_groups" edge to the InvitationFriendGroup entity.
func (m *InvitationMutation) RemovedInvitationFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_friend_groups {
		ids = append(ids, id)
	}
	return
}

// InvitationFriendGroupsIDs returns the "invitation_friend_groups" edge IDs in the mutation.
func (m *InvitationMutation) InvitationFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationFriendGroups resets all changes to the "invitation_friend_groups" edge.
func (m *InvitationMutation) ResetInvitationFriendGroups() {
	m.invitation_friend_groups = nil
	m.clearedinvitation_friend_groups = false
	m.removedinvitation_friend_groups = nil
}

// AddInvitationAcceptanceIDs adds the "invitation_acceptances" edge to the InvitationAcceptance entity by ids.
func (m *InvitationMutation) AddInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.invitation_acceptances == nil {
		m.invitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_acceptances[ids[i]] = struct{}{}
	}
}

// ClearInvitationAcceptances clears the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *InvitationMutation) ClearInvitationAcceptances() {
	m.clearedinvitation_acceptances = true
}

// InvitationAcceptancesCleared reports if the "invitation_acceptances" edge to the InvitationAcceptance entity was cleared.
func (m *InvitationMutation) InvitationAcceptancesCleared() bool {
	return m.clearedinvitation_acceptances
}

// RemoveInvitationAcceptanceIDs removes the "invitation_acceptances" edge to the InvitationAcceptance entity by IDs.
func (m *InvitationMutation) RemoveInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.removedinvitation_acceptances == nil {
		m.removedinvitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_acceptances, ids[i])
		m.removedinvitation_acceptances[ids[i]] = struct{}{}
	}
}

// RemovedInvitationAcceptances returns the removed IDs of the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *InvitationMutation) RemovedInvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// InvitationAcceptancesIDs returns the "invitation_acceptances" edge IDs in the mutation.
func (m *InvitationMutation) InvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.invitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationAcceptances resets all changes to the "invitation_acceptances" edge.
func (m *InvitationMutation) ResetInvitationAcceptances() {
	m.invitation_acceptances = nil
	m.clearedinvitation_acceptances = false
	m.removedinvitation_acceptances = nil
}

// AddInvitationDenialIDs adds the "invitation_denials" edge to the InvitationDenial entity by ids.
func (m *InvitationMutation) AddInvitationDenialIDs(ids ...uuid.UUID) {
	if m.invitation_denials == nil {
		m.invitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_denials[ids[i]] = struct{}{}
	}
}

// ClearInvitationDenials clears the "invitation_denials" edge to the InvitationDenial entity.
func (m *InvitationMutation) ClearInvitationDenials() {
	m.clearedinvitation_denials = true
}

// InvitationDenialsCleared reports if the "invitation_denials" edge to the InvitationDenial entity was cleared.
func (m *InvitationMutation) InvitationDenialsCleared() bool {
	return m.clearedinvitation_denials
}

// RemoveInvitationDenialIDs removes the "invitation_denials" edge to the InvitationDenial entity by IDs.
func (m *InvitationMutation) RemoveInvitationDenialIDs(ids ...uuid.UUID) {
	if m.removedinvitation_denials == nil {
		m.removedinvitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_denials, ids[i])
		m.removedinvitation_denials[ids[i]] = struct{}{}
	}
}

// RemovedInvitationDenials returns the removed IDs of the "invitation_denials" edge to the InvitationDenial entity.
func (m *InvitationMutation) RemovedInvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_denials {
		ids = append(ids, id)
	}
	return
}

// InvitationDenialsIDs returns the "invitation_denials" edge IDs in the mutation.
func (m *InvitationMutation) InvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_denials {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationDenials resets all changes to the "invitation_denials" edge.
func (m *InvitationMutation) ResetInvitationDenials() {
	m.invitation_denials = nil
	m.clearedinvitation_denials = false
	m.removedinvitation_denials = nil
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, invitation.FieldUserID)
	}
	if m.location != nil {
		fields = append(fields, invitation.FieldLocation)
	}
	if m.comment != nil {
		fields = append(fields, invitation.FieldComment)
	}
	if m.starts_at != nil {
		fields = append(fields, invitation.FieldStartsAt)
	}
	if m.expires_at != nil {
		fields = append(fields, invitation.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, invitation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldUserID:
		return m.UserID()
	case invitation.FieldLocation:
		return m.Location()
	case invitation.FieldComment:
		return m.Comment()
	case invitation.FieldStartsAt:
		return m.StartsAt()
	case invitation.FieldExpiresAt:
		return m.ExpiresAt()
	case invitation.FieldCreatedAt:
		return m.CreatedAt()
	case invitation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldUserID:
		return m.OldUserID(ctx)
	case invitation.FieldLocation:
		return m.OldLocation(ctx)
	case invitation.FieldComment:
		return m.OldComment(ctx)
	case invitation.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case invitation.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case invitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case invitation.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case invitation.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case invitation.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case invitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldUserID:
		m.ResetUserID()
		return nil
	case invitation.FieldLocation:
		m.ResetLocation()
		return nil
	case invitation.FieldComment:
		m.ResetComment()
		return nil
	case invitation.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case invitation.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case invitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, invitation.EdgeUser)
	}
	if m.invitation_users != nil {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.invitation_friend_groups != nil {
		edges = append(edges, invitation.EdgeInvitationFriendGroups)
	}
	if m.invitation_acceptances != nil {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.invitation_denials != nil {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitation.EdgeInvitationUsers:
		ids := make([]ent.Value, 0, len(m.invitation_users))
		for id := range m.invitation_users {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationFriendGroups:
		ids := make([]ent.Value, 0, len(m.invitation_friend_groups))
		for id := range m.invitation_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.invitation_acceptances))
		for id := range m.invitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.invitation_denials))
		for id := range m.invitation_denials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedinvitation_users != nil {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.removedinvitation_friend_groups != nil {
		edges = append(edges, invitation.EdgeInvitationFriendGroups)
	}
	if m.removedinvitation_acceptances != nil {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.removedinvitation_denials != nil {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeInvitationUsers:
		ids := make([]ent.Value, 0, len(m.removedinvitation_users))
		for id := range m.removedinvitation_users {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedinvitation_friend_groups))
		for id := range m.removedinvitation_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.removedinvitation_acceptances))
		for id := range m.removedinvitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.removedinvitation_denials))
		for id := range m.removedinvitation_denials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, invitation.EdgeUser)
	}
	if m.clearedinvitation_users {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.clearedinvitation_friend_groups {
		edges = append(edges, invitation.EdgeInvitationFriendGroups)
	}
	if m.clearedinvitation_acceptances {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.clearedinvitation_denials {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeUser:
		return m.cleareduser
	case invitation.EdgeInvitationUsers:
		return m.clearedinvitation_users
	case invitation.EdgeInvitationFriendGroups:
		return m.clearedinvitation_friend_groups
	case invitation.EdgeInvitationAcceptances:
		return m.clearedinvitation_acceptances
	case invitation.EdgeInvitationDenials:
		return m.clearedinvitation_denials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeUser:
		m.ResetUser()
		return nil
	case invitation.EdgeInvitationUsers:
		m.ResetInvitationUsers()
		return nil
	case invitation.EdgeInvitationFriendGroups:
		m.ResetInvitationFriendGroups()
		return nil
	case invitation.EdgeInvitationAcceptances:
		m.ResetInvitationAcceptances()
		return nil
	case invitation.EdgeInvitationDenials:
		m.ResetInvitationDenials()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// InvitationAcceptanceMutation represents an operation that mutates the InvitationAcceptance nodes in the graph.
type InvitationAcceptanceMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	invitation        *uuid.UUID
	clearedinvitation bool
	done              bool
	oldValue          func(context.Context) (*InvitationAcceptance, error)
	predicates        []predicate.InvitationAcceptance
}

var _ ent.Mutation = (*InvitationAcceptanceMutation)(nil)

// invitationacceptanceOption allows management of the mutation configuration using functional options.
type invitationacceptanceOption func(*InvitationAcceptanceMutation)

// newInvitationAcceptanceMutation creates new mutation for the InvitationAcceptance entity.
func newInvitationAcceptanceMutation(c config, op Op, opts ...invitationacceptanceOption) *InvitationAcceptanceMutation {
	m := &InvitationAcceptanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationAcceptance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationAcceptanceID sets the ID field of the mutation.
func withInvitationAcceptanceID(id uuid.UUID) invitationacceptanceOption {
	return func(m *InvitationAcceptanceMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationAcceptance
		)
		m.oldValue = func(ctx context.Context) (*InvitationAcceptance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationAcceptance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationAcceptance sets the old InvitationAcceptance of the mutation.
func withInvitationAcceptance(node *InvitationAcceptance) invitationacceptanceOption {
	return func(m *InvitationAcceptanceMutation) {
		m.oldValue = func(context.Context) (*InvitationAcceptance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationAcceptanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationAcceptanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationAcceptance entities.
func (m *InvitationAcceptanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationAcceptanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationAcceptanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationAcceptance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationAcceptanceMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationAcceptanceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationAcceptanceMutation) ResetUserID() {
	m.user = nil
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationAcceptanceMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationAcceptanceMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationAcceptanceMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationAcceptanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationAcceptanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationAcceptanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationAcceptanceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationAcceptanceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationAcceptanceMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationAcceptanceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationAcceptanceMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationAcceptanceMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationAcceptanceMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationAcceptanceMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// Where appends a list predicates to the InvitationAcceptanceMutation builder.
func (m *InvitationAcceptanceMutation) Where(ps ...predicate.InvitationAcceptance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationAcceptanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationAcceptance).
func (m *InvitationAcceptanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationAcceptanceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, invitationacceptance.FieldUserID)
	}
	if m.invitation != nil {
		fields = append(fields, invitationacceptance.FieldInvitationID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationacceptance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationAcceptanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationacceptance.FieldUserID:
		return m.UserID()
	case invitationacceptance.FieldInvitationID:
		return m.InvitationID()
	case invitationacceptance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationAcceptanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationacceptance.FieldUserID:
		return m.OldUserID(ctx)
	case invitationacceptance.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationacceptance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationAcceptanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationacceptance.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationacceptance.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationacceptance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationAcceptanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationAcceptanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationAcceptanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationAcceptance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationAcceptanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationAcceptanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationAcceptanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationAcceptance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationAcceptanceMutation) ResetField(name string) error {
	switch name {
	case invitationacceptance.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationacceptance.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationacceptance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationAcceptanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, invitationacceptance.EdgeUser)
	}
	if m.invitation != nil {
		edges = append(edges, invitationacceptance.EdgeInvitation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationAcceptanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationacceptance.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitationacceptance.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationAcceptanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationAcceptanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationAcceptanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, invitationacceptance.EdgeUser)
	}
	if m.clearedinvitation {
		edges = append(edges, invitationacceptance.EdgeInvitation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationAcceptanceMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationacceptance.EdgeUser:
		return m.cleareduser
	case invitationacceptance.EdgeInvitation:
		return m.clearedinvitation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationAcceptanceMutation) ClearEdge(name string) error {
	switch name {
	case invitationacceptance.EdgeUser:
		m.ClearUser()
		return nil
	case invitationacceptance.EdgeInvitation:
		m.ClearInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationAcceptanceMutation) ResetEdge(name string) error {
	switch name {
	case invitationacceptance.EdgeUser:
		m.ResetUser()
		return nil
	case invitationacceptance.EdgeInvitation:
		m.ResetInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance edge %s", name)
}

// InvitationDenialMutation represents an operation that mutates the InvitationDenial nodes in the graph.
type InvitationDenialMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	invitation        *uuid.UUID
	clearedinvitation bool
	done              bool
	oldValue          func(context.Context) (*InvitationDenial, error)
	predicates        []predicate.InvitationDenial
}

var _ ent.Mutation = (*InvitationDenialMutation)(nil)

// invitationdenialOption allows management of the mutation configuration using functional options.
type invitationdenialOption func(*InvitationDenialMutation)

// newInvitationDenialMutation creates new mutation for the InvitationDenial entity.
func newInvitationDenialMutation(c config, op Op, opts ...invitationdenialOption) *InvitationDenialMutation {
	m := &InvitationDenialMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationDenial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationDenialID sets the ID field of the mutation.
func withInvitationDenialID(id uuid.UUID) invitationdenialOption {
	return func(m *InvitationDenialMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationDenial
		)
		m.oldValue = func(ctx context.Context) (*InvitationDenial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationDenial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationDenial sets the old InvitationDenial of the mutation.
func withInvitationDenial(node *InvitationDenial) invitationdenialOption {
	return func(m *InvitationDenialMutation) {
		m.oldValue = func(context.Context) (*InvitationDenial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationDenialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationDenialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationDenial entities.
func (m *InvitationDenialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationDenialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationDenialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationDenial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationDenialMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationDenialMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationDenialMutation) ResetUserID() {
	m.user = nil
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationDenialMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationDenialMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationDenialMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationDenialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationDenialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationDenialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationDenialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationDenialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationDenialMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationDenialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationDenialMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationDenialMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationDenialMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationDenialMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// Where appends a list predicates to the InvitationDenialMutation builder.
func (m *InvitationDenialMutation) Where(ps ...predicate.InvitationDenial) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationDenialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationDenial).
func (m *InvitationDenialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationDenialMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, invitationdenial.FieldUserID)
	}
	if m.invitation != nil {
		fields = append(fields, invitationdenial.FieldInvitationID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationdenial.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationDenialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationdenial.FieldUserID:
		return m.UserID()
	case invitationdenial.FieldInvitationID:
		return m.InvitationID()
	case invitationdenial.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationDenialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationdenial.FieldUserID:
		return m.OldUserID(ctx)
	case invitationdenial.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationdenial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationDenial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationDenialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationdenial.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationdenial.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationdenial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationDenialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationDenialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationDenialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationDenial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationDenialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationDenialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationDenialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationDenial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationDenialMutation) ResetField(name string) error {
	switch name {
	case invitationdenial.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationdenial.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationdenial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationDenialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, invitationdenial.EdgeUser)
	}
	if m.invitation != nil {
		edges = append(edges, invitationdenial.EdgeInvitation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationDenialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationdenial.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitationdenial.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationDenialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationDenialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationDenialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, invitationdenial.EdgeUser)
	}
	if m.clearedinvitation {
		edges = append(edges, invitationdenial.EdgeInvitation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationDenialMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationdenial.EdgeUser:
		return m.cleareduser
	case invitationdenial.EdgeInvitation:
		return m.clearedinvitation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationDenialMutation) ClearEdge(name string) error {
	switch name {
	case invitationdenial.EdgeUser:
		m.ClearUser()
		return nil
	case invitationdenial.EdgeInvitation:
		m.ClearInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationDenialMutation) ResetEdge(name string) error {
	switch name {
	case invitationdenial.EdgeUser:
		m.ResetUser()
		return nil
	case invitationdenial.EdgeInvitation:
		m.ResetInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial edge %s", name)
}

// InvitationFriendGroupMutation represents an operation that mutates the InvitationFriendGroup nodes in the graph.
type InvitationFriendGroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	clearedFields       map[string]struct{}
	invitation          *uuid.UUID
	clearedinvitation   bool
	friend_group        *uuid.UUID
	clearedfriend_group bool
	done                bool
	oldValue            func(context.Context) (*InvitationFriendGroup, error)
	predicates          []predicate.InvitationFriendGroup
}

var _ ent.Mutation = (*InvitationFriendGroupMutation)(nil)

// invitationfriendgroupOption allows management of the mutation configuration using functional options.
type invitationfriendgroupOption func(*InvitationFriendGroupMutation)

// newInvitationFriendGroupMutation creates new mutation for the InvitationFriendGroup entity.
func newInvitationFriendGroupMutation(c config, op Op, opts ...invitationfriendgroupOption) *InvitationFriendGroupMutation {
	m := &InvitationFriendGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationFriendGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationFriendGroupID sets the ID field of the mutation.
func withInvitationFriendGroupID(id uuid.UUID) invitationfriendgroupOption {
	return func(m *InvitationFriendGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationFriendGroup
		)
		m.oldValue = func(ctx context.Context) (*InvitationFriendGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationFriendGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationFriendGroup sets the old InvitationFriendGroup of the mutation.
func withInvitationFriendGroup(node *InvitationFriendGroup) invitationfriendgroupOption {
	return func(m *InvitationFriendGroupMutation) {
		m.oldValue = func(context.Context) (*InvitationFriendGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationFriendGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationFriendGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationFriendGroup entities.
func (m *InvitationFriendGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationFriendGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationFriendGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationFriendGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationFriendGroupMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationFriendGroupMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationFriendGroup entity.
// If the InvitationFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationFriendGroupMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationFriendGroupMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetFriendGroupID sets the "friend_group_id" field.
func (m *InvitationFriendGroupMutation) SetFriendGroupID(u uuid.UUID) {
	m.friend_group = &u
}

// FriendGroupID returns the value of the "friend_group_id" field in the mutation.
func (m *InvitationFriendGroupMutation) FriendGroupID() (r uuid.UUID, exists bool) {
	v := m.friend_group
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendGroupID returns the old "friend_group_id" field's value of the InvitationFriendGroup entity.
// If the InvitationFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationFriendGroupMutation) OldFriendGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendGroupID: %w", err)
	}
	return oldValue.FriendGroupID, nil
}

// ResetFriendGroupID resets all changes to the "friend_group_id" field.
func (m *InvitationFriendGroupMutation) ResetFriendGroupID() {
	m.friend_group = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationFriendGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationFriendGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationFriendGroup entity.
// If the InvitationFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationFriendGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationFriendGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationFriendGroupMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationFriendGroupMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationFriendGroupMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationFriendGroupMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// ClearFriendGroup clears the "friend_group" edge to the FriendGroup entity.
func (m *InvitationFriendGroupMutation) ClearFriendGroup() {
	m.clearedfriend_group = true
}

// FriendGroupCleared reports if the "friend_group" edge to the FriendGroup entity was cleared.
func (m *InvitationFriendGroupMutation) FriendGroupCleared() bool {
	return m.clearedfriend_group
}

// FriendGroupIDs returns the "friend_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendGroupID instead. It exists only for internal usage by the builders.
func (m *InvitationFriendGroupMutation) FriendGroupIDs() (ids []uuid.UUID) {
	if id := m.friend_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriendGroup resets all changes to the "friend_group" edge.
func (m *InvitationFriendGroupMutation) ResetFriendGroup() {
	m.friend_group = nil
	m.clearedfriend_group = false
}

// Where appends a list predicates to the InvitationFriendGroupMutation builder.
func (m *InvitationFriendGroupMutation) Where(ps ...predicate.InvitationFriendGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationFriendGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationFriendGroup).
func (m *InvitationFriendGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationFriendGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.invitation != nil {
		fields = append(fields, invitationfriendgroup.FieldInvitationID)
	}
	if m.friend_group != nil {
		fields = append(fields, invitationfriendgroup.FieldFriendGroupID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationfriendgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationFriendGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationfriendgroup.FieldInvitationID:
		return m.InvitationID()
	case invitationfriendgroup.FieldFriendGroupID:
		return m.FriendGroupID()
	case invitationfriendgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationFriendGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationfriendgroup.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationfriendgroup.FieldFriendGroupID:
		return m.OldFriendGroupID(ctx)
	case invitationfriendgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationFriendGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationFriendGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationfriendgroup.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationfriendgroup.FieldFriendGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendGroupID(v)
		return nil
	case invitationfriendgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationFriendGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationFriendGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationFriendGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationFriendGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationFriendGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationFriendGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationFriendGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationFriendGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationFriendGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationFriendGroupMutation) ResetField(name string) error {
	switch name {
	case invitationfriendgroup.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationfriendgroup.FieldFriendGroupID:
		m.ResetFriendGroupID()
		return nil
	case invitationfriendgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationFriendGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationFriendGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invitation != nil {
		edges = append(edges, invitationfriendgroup.EdgeInvitation)
	}
	if m.friend_group != nil {
		edges = append(edges, invitationfriendgroup.EdgeFriendGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationFriendGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationfriendgroup.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	case invitationfriendgroup.EdgeFriendGroup:
		if id := m.friend_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationFriendGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationFriendGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationFriendGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvitation {
		edges = append(edges, invitationfriendgroup.EdgeInvitation)
	}
	if m.clearedfriend_group {
		edges = append(edges, invitationfriendgroup.EdgeFriendGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationFriendGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationfriendgroup.EdgeInvitation:
		return m.clearedinvitation
	case invitationfriendgroup.EdgeFriendGroup:
		return m.clearedfriend_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationFriendGroupMutation) ClearEdge(name string) error {
	switch name {
	case invitationfriendgroup.EdgeInvitation:
		m.ClearInvitation()
		return nil
	case invitationfriendgroup.EdgeFriendGroup:
		m.ClearFriendGroup()
		return nil
	}
	return fmt.Errorf("unknown InvitationFriendGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationFriendGroupMutation) ResetEdge(name string) error {
	switch name {
	case invitationfriendgroup.EdgeInvitation:
		m.ResetInvitation()
		return nil
	case invitationfriendgroup.EdgeFriendGroup:
		m.ResetFriendGroup()
		return nil
	}
	return fmt.Errorf("unknown InvitationFriendGroup edge %s", name)
}

// InvitationUserMutation represents an operation that mutates the InvitationUser nodes in the graph.
type InvitationUserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	invitation        *uuid.UUID
	clearedinvitation bool
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*InvitationUser, error)
	predicates        []predicate.InvitationUser
}

var _ ent.Mutation = (*InvitationUserMutation)(nil)

// invitationuserOption allows management of the mutation configuration using functional options.
type invitationuserOption func(*InvitationUserMutation)

// newInvitationUserMutation creates new mutation for the InvitationUser entity.
func newInvitationUserMutation(c config, op Op, opts ...invitationuserOption) *InvitationUserMutation {
	m := &InvitationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationUserID sets the ID field of the mutation.
func withInvitationUserID(id uuid.UUID) invitationuserOption {
	return func(m *InvitationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationUser
		)
		m.oldValue = func(ctx context.Context) (*InvitationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationUser sets the old InvitationUser of the mutation.
func withInvitationUser(node *InvitationUser) invitationuserOption {
	return func(m *InvitationUserMutation) {
		m.oldValue = func(context.Context) (*InvitationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationUser entities.
func (m *InvitationUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationUserMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationUserMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationUserMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetUserID sets the "user_id" field.
func (m *InvitationUserMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationUserMutation) ResetUserID() {
	m.user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationUserMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationUserMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationUserMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationUserMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationUserMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the InvitationUserMutation builder.
func (m *InvitationUserMutation) Where(ps ...predicate.InvitationUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationUser).
func (m *InvitationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.invitation != nil {
		fields = append(fields, invitationuser.FieldInvitationID)
	}
	if m.user != nil {
		fields = append(fields, invitationuser.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationuser.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationuser.FieldInvitationID:
		return m.InvitationID()
	case invitationuser.FieldUserID:
		return m.UserID()
	case invitationuser.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationuser.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationuser.FieldUserID:
		return m.OldUserID(ctx)
	case invitationuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationuser.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationUserMutation) ResetField(name string) error {
	switch name {
	case invitationuser.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationuser.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invitation != nil {
		edges = append(edges, invitationuser.EdgeInvitation)
	}
	if m.user != nil {
		edges = append(edges, invitationuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationuser.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	case invitationuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvitation {
		edges = append(edges, invitationuser.EdgeInvitation)
	}
	if m.cleareduser {
		edges = append(edges, invitationuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationUserMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationuser.EdgeInvitation:
		return m.clearedinvitation
	case invitationuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationUserMutation) ClearEdge(name string) error {
	switch name {
	case invitationuser.EdgeInvitation:
		m.ClearInvitation()
		return nil
	case invitationuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationUserMutation) ResetEdge(name string) error {
	switch name {
	case invitationuser.EdgeInvitation:
		m.ResetInvitation()
		return nil
	case invitationuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	auth_id                        *string
	created_at                     *time.Time
	clearedFields                  map[string]struct{}
	user_profile                   *uuid.UUID
	cleareduser_profile            bool
	friend_users                   map[uuid.UUID]struct{}
	removedfriend_users            map[uuid.UUID]struct{}
	clearedfriend_users            bool
	friend_groups                  map[uuid.UUID]struct{}
	removedfriend_groups           map[uuid.UUID]struct{}
	clearedfriend_groups           bool
	belonging_friend_groups        map[uuid.UUID]struct{}
	removedbelonging_friend_groups map[uuid.UUID]struct{}
	clearedbelonging_friend_groups bool
	invitation_acceptances         map[uuid.UUID]struct{}
	removedinvitation_acceptances  map[uuid.UUID]struct{}
	clearedinvitation_acceptances  bool
	invitation_denials             map[uuid.UUID]struct{}
	removedinvitation_denials      map[uuid.UUID]struct{}
	clearedinvitation_denials      bool
	friendships                    map[uuid.UUID]struct{}
	removedfriendships             map[uuid.UUID]struct{}
	clearedfriendships             bool
	user_friend_groups             map[uuid.UUID]struct{}
	removeduser_friend_groups      map[uuid.UUID]struct{}
	cleareduser_friend_groups      bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthID sets the "auth_id" field.
func (m *UserMutation) SetAuthID(s string) {
	m.auth_id = &s
}

// AuthID returns the value of the "auth_id" field in the mutation.
func (m *UserMutation) AuthID() (r string, exists bool) {
	v := m.auth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthID returns the old "auth_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthID: %w", err)
	}
	return oldValue.AuthID, nil
}

// ResetAuthID resets all changes to the "auth_id" field.
func (m *UserMutation) ResetAuthID() {
	m.auth_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserProfileID sets the "user_profile" edge to the UserProfile entity by id.
func (m *UserMutation) SetUserProfileID(id uuid.UUID) {
	m.user_profile = &id
}

// ClearUserProfile clears the "user_profile" edge to the UserProfile entity.
func (m *UserMutation) ClearUserProfile() {
	m.cleareduser_profile = true
}

// UserProfileCleared reports if the "user_profile" edge to the UserProfile entity was cleared.
func (m *UserMutation) UserProfileCleared() bool {
	return m.cleareduser_profile
}

// UserProfileID returns the "user_profile" edge ID in the mutation.
func (m *UserMutation) UserProfileID() (id uuid.UUID, exists bool) {
	if m.user_profile != nil {
		return *m.user_profile, true
	}
	return
}

// UserProfileIDs returns the "user_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserProfileIDs() (ids []uuid.UUID) {
	if id := m.user_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserProfile resets all changes to the "user_profile" edge.
func (m *UserMutation) ResetUserProfile() {
	m.user_profile = nil
	m.cleareduser_profile = false
}

// AddFriendUserIDs adds the "friend_users" edge to the User entity by ids.
func (m *UserMutation) AddFriendUserIDs(ids ...uuid.UUID) {
	if m.friend_users == nil {
		m.friend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_users[ids[i]] = struct{}{}
	}
}

// ClearFriendUsers clears the "friend_users" edge to the User entity.
func (m *UserMutation) ClearFriendUsers() {
	m.clearedfriend_users = true
}

// FriendUsersCleared reports if the "friend_users" edge to the User entity was cleared.
func (m *UserMutation) FriendUsersCleared() bool {
	return m.clearedfriend_users
}

// RemoveFriendUserIDs removes the "friend_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveFriendUserIDs(ids ...uuid.UUID) {
	if m.removedfriend_users == nil {
		m.removedfriend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_users, ids[i])
		m.removedfriend_users[ids[i]] = struct{}{}
	}
}

// RemovedFriendUsers returns the removed IDs of the "friend_users" edge to the User entity.
func (m *UserMutation) RemovedFriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_users {
		ids = append(ids, id)
	}
	return
}

// FriendUsersIDs returns the "friend_users" edge IDs in the mutation.
func (m *UserMutation) FriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.friend_users {
		ids = append(ids, id)
	}
	return
}

// ResetFriendUsers resets all changes to the "friend_users" edge.
func (m *UserMutation) ResetFriendUsers() {
	m.friend_users = nil
	m.clearedfriend_users = false
	m.removedfriend_users = nil
}

// AddFriendGroupIDs adds the "friend_groups" edge to the FriendGroup entity by ids.
func (m *UserMutation) AddFriendGroupIDs(ids ...uuid.UUID) {
	if m.friend_groups == nil {
		m.friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_groups[ids[i]] = struct{}{}
	}
}

// ClearFriendGroups clears the "friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) ClearFriendGroups() {
	m.clearedfriend_groups = true
}

// FriendGroupsCleared reports if the "friend_groups" edge to the FriendGroup entity was cleared.
func (m *UserMutation) FriendGroupsCleared() bool {
	return m.clearedfriend_groups
}

// RemoveFriendGroupIDs removes the "friend_groups" edge to the FriendGroup entity by IDs.
func (m *UserMutation) RemoveFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedfriend_groups == nil {
		m.removedfriend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_groups, ids[i])
		m.removedfriend_groups[ids[i]] = struct{}{}
	}
}

// RemovedFriendGroups returns the removed IDs of the "friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) RemovedFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_groups {
		ids = append(ids, id)
	}
	return
}

// FriendGroupsIDs returns the "friend_groups" edge IDs in the mutation.
func (m *UserMutation) FriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetFriendGroups resets all changes to the "friend_groups" edge.
func (m *UserMutation) ResetFriendGroups() {
	m.friend_groups = nil
	m.clearedfriend_groups = false
	m.removedfriend_groups = nil
}

// AddBelongingFriendGroupIDs adds the "belonging_friend_groups" edge to the FriendGroup entity by ids.
func (m *UserMutation) AddBelongingFriendGroupIDs(ids ...uuid.UUID) {
	if m.belonging_friend_groups == nil {
		m.belonging_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.belonging_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearBelongingFriendGroups clears the "belonging_friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) ClearBelongingFriendGroups() {
	m.clearedbelonging_friend_groups = true
}

// BelongingFriendGroupsCleared reports if the "belonging_friend_groups" edge to the FriendGroup entity was cleared.
func (m *UserMutation) BelongingFriendGroupsCleared() bool {
	return m.clearedbelonging_friend_groups
}

// RemoveBelongingFriendGroupIDs removes the "belonging_friend_groups" edge to the FriendGroup entity by IDs.
func (m *UserMutation) RemoveBelongingFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedbelonging_friend_groups == nil {
		m.removedbelonging_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.belonging_friend_groups, ids[i])
		m.removedbelonging_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedBelongingFriendGroups returns the removed IDs of the "belonging_friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) RemovedBelongingFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedbelonging_friend_groups {
		ids = append(ids, id)
	}
	return
}

// BelongingFriendGroupsIDs returns the "belonging_friend_groups" edge IDs in the mutation.
func (m *UserMutation) BelongingFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.belonging_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetBelongingFriendGroups resets all changes to the "belonging_friend_groups" edge.
func (m *UserMutation) ResetBelongingFriendGroups() {
	m.belonging_friend_groups = nil
	m.clearedbelonging_friend_groups = false
	m.removedbelonging_friend_groups = nil
}

// AddInvitationAcceptanceIDs adds the "invitation_acceptances" edge to the InvitationAcceptance entity by ids.
func (m *UserMutation) AddInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.invitation_acceptances == nil {
		m.invitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_acceptances[ids[i]] = struct{}{}
	}
}

// ClearInvitationAcceptances clears the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *UserMutation) ClearInvitationAcceptances() {
	m.clearedinvitation_acceptances = true
}

// InvitationAcceptancesCleared reports if the "invitation_acceptances" edge to the InvitationAcceptance entity was cleared.
func (m *UserMutation) InvitationAcceptancesCleared() bool {
	return m.clearedinvitation_acceptances
}

// RemoveInvitationAcceptanceIDs removes the "invitation_acceptances" edge to the InvitationAcceptance entity by IDs.
func (m *UserMutation) RemoveInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.removedinvitation_acceptances == nil {
		m.removedinvitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_acceptances, ids[i])
		m.removedinvitation_acceptances[ids[i]] = struct{}{}
	}
}

// RemovedInvitationAcceptances returns the removed IDs of the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *UserMutation) RemovedInvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// InvitationAcceptancesIDs returns the "invitation_acceptances" edge IDs in the mutation.
func (m *UserMutation) InvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.invitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationAcceptances resets all changes to the "invitation_acceptances" edge.
func (m *UserMutation) ResetInvitationAcceptances() {
	m.invitation_acceptances = nil
	m.clearedinvitation_acceptances = false
	m.removedinvitation_acceptances = nil
}

// AddInvitationDenialIDs adds the "invitation_denials" edge to the InvitationDenial entity by ids.
func (m *UserMutation) AddInvitationDenialIDs(ids ...uuid.UUID) {
	if m.invitation_denials == nil {
		m.invitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_denials[ids[i]] = struct{}{}
	}
}

// ClearInvitationDenials clears the "invitation_denials" edge to the InvitationDenial entity.
func (m *UserMutation) ClearInvitationDenials() {
	m.clearedinvitation_denials = true
}

// InvitationDenialsCleared reports if the "invitation_denials" edge to the InvitationDenial entity was cleared.
func (m *UserMutation) InvitationDenialsCleared() bool {
	return m.clearedinvitation_denials
}

// RemoveInvitationDenialIDs removes the "invitation_denials" edge to the InvitationDenial entity by IDs.
func (m *UserMutation) RemoveInvitationDenialIDs(ids ...uuid.UUID) {
	if m.removedinvitation_denials == nil {
		m.removedinvitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_denials, ids[i])
		m.removedinvitation_denials[ids[i]] = struct{}{}
	}
}

// RemovedInvitationDenials returns the removed IDs of the "invitation_denials" edge to the InvitationDenial entity.
func (m *UserMutation) RemovedInvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_denials {
		ids = append(ids, id)
	}
	return
}

// InvitationDenialsIDs returns the "invitation_denials" edge IDs in the mutation.
func (m *UserMutation) InvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_denials {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationDenials resets all changes to the "invitation_denials" edge.
func (m *UserMutation) ResetInvitationDenials() {
	m.invitation_denials = nil
	m.clearedinvitation_denials = false
	m.removedinvitation_denials = nil
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by ids.
func (m *UserMutation) AddFriendshipIDs(ids ...uuid.UUID) {
	if m.friendships == nil {
		m.friendships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friendships[ids[i]] = struct{}{}
	}
}

// ClearFriendships clears the "friendships" edge to the Friendship entity.
func (m *UserMutation) ClearFriendships() {
	m.clearedfriendships = true
}

// FriendshipsCleared reports if the "friendships" edge to the Friendship entity was cleared.
func (m *UserMutation) FriendshipsCleared() bool {
	return m.clearedfriendships
}

// RemoveFriendshipIDs removes the "friendships" edge to the Friendship entity by IDs.
func (m *UserMutation) RemoveFriendshipIDs(ids ...uuid.UUID) {
	if m.removedfriendships == nil {
		m.removedfriendships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friendships, ids[i])
		m.removedfriendships[ids[i]] = struct{}{}
	}
}

// RemovedFriendships returns the removed IDs of the "friendships" edge to the Friendship entity.
func (m *UserMutation) RemovedFriendshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedfriendships {
		ids = append(ids, id)
	}
	return
}

// FriendshipsIDs returns the "friendships" edge IDs in the mutation.
func (m *UserMutation) FriendshipsIDs() (ids []uuid.UUID) {
	for id := range m.friendships {
		ids = append(ids, id)
	}
	return
}

// ResetFriendships resets all changes to the "friendships" edge.
func (m *UserMutation) ResetFriendships() {
	m.friendships = nil
	m.clearedfriendships = false
	m.removedfriendships = nil
}

// AddUserFriendGroupIDs adds the "user_friend_groups" edge to the UserFriendGroup entity by ids.
func (m *UserMutation) AddUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.user_friend_groups == nil {
		m.user_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearUserFriendGroups clears the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *UserMutation) ClearUserFriendGroups() {
	m.cleareduser_friend_groups = true
}

// UserFriendGroupsCleared reports if the "user_friend_groups" edge to the UserFriendGroup entity was cleared.
func (m *UserMutation) UserFriendGroupsCleared() bool {
	return m.cleareduser_friend_groups
}

// RemoveUserFriendGroupIDs removes the "user_friend_groups" edge to the UserFriendGroup entity by IDs.
func (m *UserMutation) RemoveUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.removeduser_friend_groups == nil {
		m.removeduser_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_friend_groups, ids[i])
		m.removeduser_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserFriendGroups returns the removed IDs of the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *UserMutation) RemovedUserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_friend_groups {
		ids = append(ids, id)
	}
	return
}

// UserFriendGroupsIDs returns the "user_friend_groups" edge IDs in the mutation.
func (m *UserMutation) UserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.user_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserFriendGroups resets all changes to the "user_friend_groups" edge.
func (m *UserMutation) ResetUserFriendGroups() {
	m.user_friend_groups = nil
	m.cleareduser_friend_groups = false
	m.removeduser_friend_groups = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.auth_id != nil {
		fields = append(fields, user.FieldAuthID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAuthID:
		return m.AuthID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAuthID:
		return m.OldAuthID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAuthID:
		m.ResetAuthID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.user_profile != nil {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.friend_users != nil {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.friend_groups != nil {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.belonging_friend_groups != nil {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.invitation_acceptances != nil {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.invitation_denials != nil {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.friendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.user_friend_groups != nil {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserProfile:
		if id := m.user_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.friend_users))
		for id := range m.friend_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendGroups:
		ids := make([]ent.Value, 0, len(m.friend_groups))
		for id := range m.friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongingFriendGroups:
		ids := make([]ent.Value, 0, len(m.belonging_friend_groups))
		for id := range m.belonging_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.invitation_acceptances))
		for id := range m.invitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.invitation_denials))
		for id := range m.invitation_denials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.friendships))
		for id := range m.friendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.user_friend_groups))
		for id := range m.user_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedfriend_users != nil {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.removedfriend_groups != nil {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.removedbelonging_friend_groups != nil {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.removedinvitation_acceptances != nil {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.removedinvitation_denials != nil {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.removedfriendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.removeduser_friend_groups != nil {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.removedfriend_users))
		for id := range m.removedfriend_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedfriend_groups))
		for id := range m.removedfriend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongingFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedbelonging_friend_groups))
		for id := range m.removedbelonging_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.removedinvitation_acceptances))
		for id := range m.removedinvitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.removedinvitation_denials))
		for id := range m.removedinvitation_denials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.removedfriendships))
		for id := range m.removedfriendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_friend_groups))
		for id := range m.removeduser_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleareduser_profile {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.clearedfriend_users {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.clearedfriend_groups {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.clearedbelonging_friend_groups {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.clearedinvitation_acceptances {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.clearedinvitation_denials {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.clearedfriendships {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.cleareduser_friend_groups {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserProfile:
		return m.cleareduser_profile
	case user.EdgeFriendUsers:
		return m.clearedfriend_users
	case user.EdgeFriendGroups:
		return m.clearedfriend_groups
	case user.EdgeBelongingFriendGroups:
		return m.clearedbelonging_friend_groups
	case user.EdgeInvitationAcceptances:
		return m.clearedinvitation_acceptances
	case user.EdgeInvitationDenials:
		return m.clearedinvitation_denials
	case user.EdgeFriendships:
		return m.clearedfriendships
	case user.EdgeUserFriendGroups:
		return m.cleareduser_friend_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserProfile:
		m.ClearUserProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserProfile:
		m.ResetUserProfile()
		return nil
	case user.EdgeFriendUsers:
		m.ResetFriendUsers()
		return nil
	case user.EdgeFriendGroups:
		m.ResetFriendGroups()
		return nil
	case user.EdgeBelongingFriendGroups:
		m.ResetBelongingFriendGroups()
		return nil
	case user.EdgeInvitationAcceptances:
		m.ResetInvitationAcceptances()
		return nil
	case user.EdgeInvitationDenials:
		m.ResetInvitationDenials()
		return nil
	case user.EdgeFriendships:
		m.ResetFriendships()
		return nil
	case user.EdgeUserFriendGroups:
		m.ResetUserFriendGroups()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserFriendGroupMutation represents an operation that mutates the UserFriendGroup nodes in the graph.
type UserFriendGroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	clearedFields       map[string]struct{}
	friend_group        *uuid.UUID
	clearedfriend_group bool
	user                *uuid.UUID
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*UserFriendGroup, error)
	predicates          []predicate.UserFriendGroup
}

var _ ent.Mutation = (*UserFriendGroupMutation)(nil)

// userfriendgroupOption allows management of the mutation configuration using functional options.
type userfriendgroupOption func(*UserFriendGroupMutation)

// newUserFriendGroupMutation creates new mutation for the UserFriendGroup entity.
func newUserFriendGroupMutation(c config, op Op, opts ...userfriendgroupOption) *UserFriendGroupMutation {
	m := &UserFriendGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFriendGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFriendGroupID sets the ID field of the mutation.
func withUserFriendGroupID(id uuid.UUID) userfriendgroupOption {
	return func(m *UserFriendGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFriendGroup
		)
		m.oldValue = func(ctx context.Context) (*UserFriendGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFriendGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFriendGroup sets the old UserFriendGroup of the mutation.
func withUserFriendGroup(node *UserFriendGroup) userfriendgroupOption {
	return func(m *UserFriendGroupMutation) {
		m.oldValue = func(context.Context) (*UserFriendGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFriendGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFriendGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFriendGroup entities.
func (m *UserFriendGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFriendGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFriendGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFriendGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFriendGroupID sets the "friend_group_id" field.
func (m *UserFriendGroupMutation) SetFriendGroupID(u uuid.UUID) {
	m.friend_group = &u
}

// FriendGroupID returns the value of the "friend_group_id" field in the mutation.
func (m *UserFriendGroupMutation) FriendGroupID() (r uuid.UUID, exists bool) {
	v := m.friend_group
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendGroupID returns the old "friend_group_id" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldFriendGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendGroupID: %w", err)
	}
	return oldValue.FriendGroupID, nil
}

// ResetFriendGroupID resets all changes to the "friend_group_id" field.
func (m *UserFriendGroupMutation) ResetFriendGroupID() {
	m.friend_group = nil
}

// SetUserID sets the "user_id" field.
func (m *UserFriendGroupMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFriendGroupMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFriendGroupMutation) ResetUserID() {
	m.user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFriendGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFriendGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFriendGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFriendGroup clears the "friend_group" edge to the FriendGroup entity.
func (m *UserFriendGroupMutation) ClearFriendGroup() {
	m.clearedfriend_group = true
}

// FriendGroupCleared reports if the "friend_group" edge to the FriendGroup entity was cleared.
func (m *UserFriendGroupMutation) FriendGroupCleared() bool {
	return m.clearedfriend_group
}

// FriendGroupIDs returns the "friend_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendGroupID instead. It exists only for internal usage by the builders.
func (m *UserFriendGroupMutation) FriendGroupIDs() (ids []uuid.UUID) {
	if id := m.friend_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriendGroup resets all changes to the "friend_group" edge.
func (m *UserFriendGroupMutation) ResetFriendGroup() {
	m.friend_group = nil
	m.clearedfriend_group = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFriendGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFriendGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFriendGroupMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFriendGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserFriendGroupMutation builder.
func (m *UserFriendGroupMutation) Where(ps ...predicate.UserFriendGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserFriendGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserFriendGroup).
func (m *UserFriendGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFriendGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.friend_group != nil {
		fields = append(fields, userfriendgroup.FieldFriendGroupID)
	}
	if m.user != nil {
		fields = append(fields, userfriendgroup.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, userfriendgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFriendGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		return m.FriendGroupID()
	case userfriendgroup.FieldUserID:
		return m.UserID()
	case userfriendgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFriendGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		return m.OldFriendGroupID(ctx)
	case userfriendgroup.FieldUserID:
		return m.OldUserID(ctx)
	case userfriendgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFriendGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendGroupID(v)
		return nil
	case userfriendgroup.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfriendgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFriendGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFriendGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFriendGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFriendGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFriendGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFriendGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFriendGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFriendGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFriendGroupMutation) ResetField(name string) error {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		m.ResetFriendGroupID()
		return nil
	case userfriendgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case userfriendgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFriendGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.friend_group != nil {
		edges = append(edges, userfriendgroup.EdgeFriendGroup)
	}
	if m.user != nil {
		edges = append(edges, userfriendgroup.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFriendGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		if id := m.friend_group; id != nil {
			return []ent.Value{*id}
		}
	case userfriendgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFriendGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFriendGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFriendGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfriend_group {
		edges = append(edges, userfriendgroup.EdgeFriendGroup)
	}
	if m.cleareduser {
		edges = append(edges, userfriendgroup.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFriendGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		return m.clearedfriend_group
	case userfriendgroup.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFriendGroupMutation) ClearEdge(name string) error {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		m.ClearFriendGroup()
		return nil
	case userfriendgroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFriendGroupMutation) ResetEdge(name string) error {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		m.ResetFriendGroup()
		return nil
	case userfriendgroup.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup edge %s", name)
}

// UserMuteMutation represents an operation that mutates the UserMute nodes in the graph.
type UserMuteMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	mute_user        *uuid.UUID
	clearedmute_user bool
	done             bool
	oldValue         func(context.Context) (*UserMute, error)
	predicates       []predicate.UserMute
}

var _ ent.Mutation = (*UserMuteMutation)(nil)

// usermuteOption allows management of the mutation configuration using functional options.
type usermuteOption func(*UserMuteMutation)

// newUserMuteMutation creates new mutation for the UserMute entity.
func newUserMuteMutation(c config, op Op, opts ...usermuteOption) *UserMuteMutation {
	m := &UserMuteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMuteID sets the ID field of the mutation.
func withUserMuteID(id uuid.UUID) usermuteOption {
	return func(m *UserMuteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMute
		)
		m.oldValue = func(ctx context.Context) (*UserMute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMute sets the old UserMute of the mutation.
func withUserMute(node *UserMute) usermuteOption {
	return func(m *UserMuteMutation) {
		m.oldValue = func(context.Context) (*UserMute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMuteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMuteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserMute entities.
func (m *UserMuteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMuteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMuteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserMute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserMuteMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserMuteMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserMuteMutation) ResetUserID() {
	m.user = nil
}

// SetMuteUserID sets the "mute_user_id" field.
func (m *UserMuteMutation) SetMuteUserID(u uuid.UUID) {
	m.mute_user = &u
}

// MuteUserID returns the value of the "mute_user_id" field in the mutation.
func (m *UserMuteMutation) MuteUserID() (r uuid.UUID, exists bool) {
	v := m.mute_user
	if v == nil {
		return
	}
	return *v, true
}

// OldMuteUserID returns the old "mute_user_id" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldMuteUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMuteUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMuteUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMuteUserID: %w", err)
	}
	return oldValue.MuteUserID, nil
}

// ResetMuteUserID resets all changes to the "mute_user_id" field.
func (m *UserMuteMutation) ResetMuteUserID() {
	m.mute_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMuteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMuteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMuteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserMuteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserMuteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserMuteMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserMuteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMuteUser clears the "mute_user" edge to the User entity.
func (m *UserMuteMutation) ClearMuteUser() {
	m.clearedmute_user = true
}

// MuteUserCleared reports if the "mute_user" edge to the User entity was cleared.
func (m *UserMuteMutation) MuteUserCleared() bool {
	return m.clearedmute_user
}

// MuteUserIDs returns the "mute_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MuteUserID instead. It exists only for internal usage by the builders.
func (m *UserMuteMutation) MuteUserIDs() (ids []uuid.UUID) {
	if id := m.mute_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMuteUser resets all changes to the "mute_user" edge.
func (m *UserMuteMutation) ResetMuteUser() {
	m.mute_user = nil
	m.clearedmute_user = false
}

// Where appends a list predicates to the UserMuteMutation builder.
func (m *UserMuteMutation) Where(ps ...predicate.UserMute) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMuteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserMute).
func (m *UserMuteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMuteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, usermute.FieldUserID)
	}
	if m.mute_user != nil {
		fields = append(fields, usermute.FieldMuteUserID)
	}
	if m.created_at != nil {
		fields = append(fields, usermute.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMuteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermute.FieldUserID:
		return m.UserID()
	case usermute.FieldMuteUserID:
		return m.MuteUserID()
	case usermute.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMuteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermute.FieldUserID:
		return m.OldUserID(ctx)
	case usermute.FieldMuteUserID:
		return m.OldMuteUserID(ctx)
	case usermute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserMute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMuteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermute.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usermute.FieldMuteUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMuteUserID(v)
		return nil
	case usermute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserMute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMuteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMuteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMuteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserMute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMuteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMuteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMuteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserMute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMuteMutation) ResetField(name string) error {
	switch name {
	case usermute.FieldUserID:
		m.ResetUserID()
		return nil
	case usermute.FieldMuteUserID:
		m.ResetMuteUserID()
		return nil
	case usermute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserMute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMuteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usermute.EdgeUser)
	}
	if m.mute_user != nil {
		edges = append(edges, usermute.EdgeMuteUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMuteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermute.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usermute.EdgeMuteUser:
		if id := m.mute_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMuteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMuteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMuteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usermute.EdgeUser)
	}
	if m.clearedmute_user {
		edges = append(edges, usermute.EdgeMuteUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMuteMutation) EdgeCleared(name string) bool {
	switch name {
	case usermute.EdgeUser:
		return m.cleareduser
	case usermute.EdgeMuteUser:
		return m.clearedmute_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMuteMutation) ClearEdge(name string) error {
	switch name {
	case usermute.EdgeUser:
		m.ClearUser()
		return nil
	case usermute.EdgeMuteUser:
		m.ClearMuteUser()
		return nil
	}
	return fmt.Errorf("unknown UserMute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMuteMutation) ResetEdge(name string) error {
	switch name {
	case usermute.EdgeUser:
		m.ResetUser()
		return nil
	case usermute.EdgeMuteUser:
		m.ResetMuteUser()
		return nil
	}
	return fmt.Errorf("unknown UserMute edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	nickname      *string
	email         *string
	avatar_url    *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserProfile, error)
	predicates    []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id uuid.UUID) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProfile entities.
func (m *UserProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserProfileMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProfileMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProfileMutation) ResetUserID() {
	m.user = nil
}

// SetNickname sets the "nickname" field.
func (m *UserProfileMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserProfileMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserProfileMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *UserProfileMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserProfileMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserProfileMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[userprofile.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserProfileMutation) EmailCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserProfileMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, userprofile.FieldEmail)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserProfileMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserProfileMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserProfileMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, userprofile.FieldUserID)
	}
	if m.nickname != nil {
		fields = append(fields, userprofile.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, userprofile.FieldEmail)
	}
	if m.avatar_url != nil {
		fields = append(fields, userprofile.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, userprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userprofile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldUserID:
		return m.UserID()
	case userprofile.FieldNickname:
		return m.Nickname()
	case userprofile.FieldEmail:
		return m.Email()
	case userprofile.FieldAvatarURL:
		return m.AvatarURL()
	case userprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userprofile.FieldNickname:
		return m.OldNickname(ctx)
	case userprofile.FieldEmail:
		return m.OldEmail(ctx)
	case userprofile.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case userprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userprofile.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case userprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userprofile.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case userprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprofile.FieldEmail) {
		fields = append(fields, userprofile.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	switch name {
	case userprofile.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userprofile.FieldNickname:
		m.ResetNickname()
		return nil
	case userprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case userprofile.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case userprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
