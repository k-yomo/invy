// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/k-yomo/invy/invy_api/ent/account"
	"github.com/k-yomo/invy/invy_api/ent/friendgroup"
	"github.com/k-yomo/invy/invy_api/ent/friendship"
	"github.com/k-yomo/invy/invy_api/ent/friendshiprequest"
	"github.com/k-yomo/invy/invy_api/ent/invitation"
	"github.com/k-yomo/invy/invy_api/ent/invitationacceptance"
	"github.com/k-yomo/invy/invy_api/ent/invitationdenial"
	"github.com/k-yomo/invy/invy_api/ent/invitationuser"
	"github.com/k-yomo/invy/invy_api/ent/predicate"
	"github.com/k-yomo/invy/invy_api/ent/pushnotificationtoken"
	"github.com/k-yomo/invy/invy_api/ent/user"
	"github.com/k-yomo/invy/invy_api/ent/userblock"
	"github.com/k-yomo/invy/invy_api/ent/userfriendgroup"
	"github.com/k-yomo/invy/invy_api/ent/userlocation"
	"github.com/k-yomo/invy/invy_api/ent/usermute"
	"github.com/k-yomo/invy/invy_api/ent/userprofile"
	"github.com/k-yomo/invy/pkg/pgutil"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount               = "Account"
	TypeFriendGroup           = "FriendGroup"
	TypeFriendship            = "Friendship"
	TypeFriendshipRequest     = "FriendshipRequest"
	TypeInvitation            = "Invitation"
	TypeInvitationAcceptance  = "InvitationAcceptance"
	TypeInvitationDenial      = "InvitationDenial"
	TypeInvitationUser        = "InvitationUser"
	TypePushNotificationToken = "PushNotificationToken"
	TypeUser                  = "User"
	TypeUserBlock             = "UserBlock"
	TypeUserFriendGroup       = "UserFriendGroup"
	TypeUserLocation          = "UserLocation"
	TypeUserMute              = "UserMute"
	TypeUserProfile           = "UserProfile"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	auth_id       *string
	email         *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uuid.UUID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthID sets the "auth_id" field.
func (m *AccountMutation) SetAuthID(s string) {
	m.auth_id = &s
}

// AuthID returns the value of the "auth_id" field in the mutation.
func (m *AccountMutation) AuthID() (r string, exists bool) {
	v := m.auth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthID returns the old "auth_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthID: %w", err)
	}
	return oldValue.AuthID, nil
}

// ResetAuthID resets all changes to the "auth_id" field.
func (m *AccountMutation) ResetAuthID() {
	m.auth_id = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *AccountMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[account.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *AccountMutation) EmailCleared() bool {
	_, ok := m.clearedFields[account.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, account.FieldEmail)
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *AccountMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *AccountMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *AccountMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *AccountMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *AccountMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AccountMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.auth_id != nil {
		fields = append(fields, account.FieldAuthID)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldAuthID:
		return m.AuthID()
	case account.FieldEmail:
		return m.Email()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldAuthID:
		return m.OldAuthID(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthID(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldEmail) {
		fields = append(fields, account.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldAuthID:
		m.ResetAuthID()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, account.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, account.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, account.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// FriendGroupMutation represents an operation that mutates the FriendGroup nodes in the graph.
type FriendGroupMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	name                      *string
	total_count               *int
	addtotal_count            *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	user                      *uuid.UUID
	cleareduser               bool
	friend_users              map[uuid.UUID]struct{}
	removedfriend_users       map[uuid.UUID]struct{}
	clearedfriend_users       bool
	user_friend_groups        map[uuid.UUID]struct{}
	removeduser_friend_groups map[uuid.UUID]struct{}
	cleareduser_friend_groups bool
	done                      bool
	oldValue                  func(context.Context) (*FriendGroup, error)
	predicates                []predicate.FriendGroup
}

var _ ent.Mutation = (*FriendGroupMutation)(nil)

// friendgroupOption allows management of the mutation configuration using functional options.
type friendgroupOption func(*FriendGroupMutation)

// newFriendGroupMutation creates new mutation for the FriendGroup entity.
func newFriendGroupMutation(c config, op Op, opts ...friendgroupOption) *FriendGroupMutation {
	m := &FriendGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendGroupID sets the ID field of the mutation.
func withFriendGroupID(id uuid.UUID) friendgroupOption {
	return func(m *FriendGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendGroup
		)
		m.oldValue = func(ctx context.Context) (*FriendGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendGroup sets the old FriendGroup of the mutation.
func withFriendGroup(node *FriendGroup) friendgroupOption {
	return func(m *FriendGroupMutation) {
		m.oldValue = func(context.Context) (*FriendGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendGroup entities.
func (m *FriendGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FriendGroupMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FriendGroupMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FriendGroupMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *FriendGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FriendGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FriendGroupMutation) ResetName() {
	m.name = nil
}

// SetTotalCount sets the "total_count" field.
func (m *FriendGroupMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *FriendGroupMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *FriendGroupMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *FriendGroupMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *FriendGroupMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FriendGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FriendGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FriendGroup entity.
// If the FriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FriendGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FriendGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FriendGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FriendGroupMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FriendGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddFriendUserIDs adds the "friend_users" edge to the User entity by ids.
func (m *FriendGroupMutation) AddFriendUserIDs(ids ...uuid.UUID) {
	if m.friend_users == nil {
		m.friend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_users[ids[i]] = struct{}{}
	}
}

// ClearFriendUsers clears the "friend_users" edge to the User entity.
func (m *FriendGroupMutation) ClearFriendUsers() {
	m.clearedfriend_users = true
}

// FriendUsersCleared reports if the "friend_users" edge to the User entity was cleared.
func (m *FriendGroupMutation) FriendUsersCleared() bool {
	return m.clearedfriend_users
}

// RemoveFriendUserIDs removes the "friend_users" edge to the User entity by IDs.
func (m *FriendGroupMutation) RemoveFriendUserIDs(ids ...uuid.UUID) {
	if m.removedfriend_users == nil {
		m.removedfriend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_users, ids[i])
		m.removedfriend_users[ids[i]] = struct{}{}
	}
}

// RemovedFriendUsers returns the removed IDs of the "friend_users" edge to the User entity.
func (m *FriendGroupMutation) RemovedFriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_users {
		ids = append(ids, id)
	}
	return
}

// FriendUsersIDs returns the "friend_users" edge IDs in the mutation.
func (m *FriendGroupMutation) FriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.friend_users {
		ids = append(ids, id)
	}
	return
}

// ResetFriendUsers resets all changes to the "friend_users" edge.
func (m *FriendGroupMutation) ResetFriendUsers() {
	m.friend_users = nil
	m.clearedfriend_users = false
	m.removedfriend_users = nil
}

// AddUserFriendGroupIDs adds the "user_friend_groups" edge to the UserFriendGroup entity by ids.
func (m *FriendGroupMutation) AddUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.user_friend_groups == nil {
		m.user_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearUserFriendGroups clears the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *FriendGroupMutation) ClearUserFriendGroups() {
	m.cleareduser_friend_groups = true
}

// UserFriendGroupsCleared reports if the "user_friend_groups" edge to the UserFriendGroup entity was cleared.
func (m *FriendGroupMutation) UserFriendGroupsCleared() bool {
	return m.cleareduser_friend_groups
}

// RemoveUserFriendGroupIDs removes the "user_friend_groups" edge to the UserFriendGroup entity by IDs.
func (m *FriendGroupMutation) RemoveUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.removeduser_friend_groups == nil {
		m.removeduser_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_friend_groups, ids[i])
		m.removeduser_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserFriendGroups returns the removed IDs of the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *FriendGroupMutation) RemovedUserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_friend_groups {
		ids = append(ids, id)
	}
	return
}

// UserFriendGroupsIDs returns the "user_friend_groups" edge IDs in the mutation.
func (m *FriendGroupMutation) UserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.user_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserFriendGroups resets all changes to the "user_friend_groups" edge.
func (m *FriendGroupMutation) ResetUserFriendGroups() {
	m.user_friend_groups = nil
	m.cleareduser_friend_groups = false
	m.removeduser_friend_groups = nil
}

// Where appends a list predicates to the FriendGroupMutation builder.
func (m *FriendGroupMutation) Where(ps ...predicate.FriendGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FriendGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FriendGroup).
func (m *FriendGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, friendgroup.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, friendgroup.FieldName)
	}
	if m.total_count != nil {
		fields = append(fields, friendgroup.FieldTotalCount)
	}
	if m.created_at != nil {
		fields = append(fields, friendgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, friendgroup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendgroup.FieldUserID:
		return m.UserID()
	case friendgroup.FieldName:
		return m.Name()
	case friendgroup.FieldTotalCount:
		return m.TotalCount()
	case friendgroup.FieldCreatedAt:
		return m.CreatedAt()
	case friendgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendgroup.FieldUserID:
		return m.OldUserID(ctx)
	case friendgroup.FieldName:
		return m.OldName(ctx)
	case friendgroup.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case friendgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case friendgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendgroup.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case friendgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case friendgroup.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case friendgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case friendgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendGroupMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_count != nil {
		fields = append(fields, friendgroup.FieldTotalCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case friendgroup.FieldTotalCount:
		return m.AddedTotalCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case friendgroup.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	}
	return fmt.Errorf("unknown FriendGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FriendGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendGroupMutation) ResetField(name string) error {
	switch name {
	case friendgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case friendgroup.FieldName:
		m.ResetName()
		return nil
	case friendgroup.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case friendgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case friendgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, friendgroup.EdgeUser)
	}
	if m.friend_users != nil {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.user_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case friendgroup.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.friend_users))
		for id := range m.friend_users {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.user_friend_groups))
		for id := range m.user_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfriend_users != nil {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.removeduser_friend_groups != nil {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case friendgroup.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.removedfriend_users))
		for id := range m.removedfriend_users {
			ids = append(ids, id)
		}
		return ids
	case friendgroup.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_friend_groups))
		for id := range m.removeduser_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, friendgroup.EdgeUser)
	}
	if m.clearedfriend_users {
		edges = append(edges, friendgroup.EdgeFriendUsers)
	}
	if m.cleareduser_friend_groups {
		edges = append(edges, friendgroup.EdgeUserFriendGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case friendgroup.EdgeUser:
		return m.cleareduser
	case friendgroup.EdgeFriendUsers:
		return m.clearedfriend_users
	case friendgroup.EdgeUserFriendGroups:
		return m.cleareduser_friend_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendGroupMutation) ClearEdge(name string) error {
	switch name {
	case friendgroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendGroupMutation) ResetEdge(name string) error {
	switch name {
	case friendgroup.EdgeUser:
		m.ResetUser()
		return nil
	case friendgroup.EdgeFriendUsers:
		m.ResetFriendUsers()
		return nil
	case friendgroup.EdgeUserFriendGroups:
		m.ResetUserFriendGroups()
		return nil
	}
	return fmt.Errorf("unknown FriendGroup edge %s", name)
}

// FriendshipMutation represents an operation that mutates the Friendship nodes in the graph.
type FriendshipMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	friend_user        *uuid.UUID
	clearedfriend_user bool
	done               bool
	oldValue           func(context.Context) (*Friendship, error)
	predicates         []predicate.Friendship
}

var _ ent.Mutation = (*FriendshipMutation)(nil)

// friendshipOption allows management of the mutation configuration using functional options.
type friendshipOption func(*FriendshipMutation)

// newFriendshipMutation creates new mutation for the Friendship entity.
func newFriendshipMutation(c config, op Op, opts ...friendshipOption) *FriendshipMutation {
	m := &FriendshipMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipID sets the ID field of the mutation.
func withFriendshipID(id uuid.UUID) friendshipOption {
	return func(m *FriendshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Friendship
		)
		m.oldValue = func(ctx context.Context) (*Friendship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Friendship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendship sets the old Friendship of the mutation.
func withFriendship(node *Friendship) friendshipOption {
	return func(m *FriendshipMutation) {
		m.oldValue = func(context.Context) (*Friendship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Friendship entities.
func (m *FriendshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Friendship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FriendshipMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FriendshipMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FriendshipMutation) ResetUserID() {
	m.user = nil
}

// SetFriendUserID sets the "friend_user_id" field.
func (m *FriendshipMutation) SetFriendUserID(u uuid.UUID) {
	m.friend_user = &u
}

// FriendUserID returns the value of the "friend_user_id" field in the mutation.
func (m *FriendshipMutation) FriendUserID() (r uuid.UUID, exists bool) {
	v := m.friend_user
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendUserID returns the old "friend_user_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldFriendUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendUserID: %w", err)
	}
	return oldValue.FriendUserID, nil
}

// ResetFriendUserID resets all changes to the "friend_user_id" field.
func (m *FriendshipMutation) ResetFriendUserID() {
	m.friend_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FriendshipMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FriendshipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FriendshipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearFriendUser clears the "friend_user" edge to the User entity.
func (m *FriendshipMutation) ClearFriendUser() {
	m.clearedfriend_user = true
}

// FriendUserCleared reports if the "friend_user" edge to the User entity was cleared.
func (m *FriendshipMutation) FriendUserCleared() bool {
	return m.clearedfriend_user
}

// FriendUserIDs returns the "friend_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendUserID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) FriendUserIDs() (ids []uuid.UUID) {
	if id := m.friend_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriendUser resets all changes to the "friend_user" edge.
func (m *FriendshipMutation) ResetFriendUser() {
	m.friend_user = nil
	m.clearedfriend_user = false
}

// Where appends a list predicates to the FriendshipMutation builder.
func (m *FriendshipMutation) Where(ps ...predicate.Friendship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Friendship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Friendship).
func (m *FriendshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, friendship.FieldUserID)
	}
	if m.friend_user != nil {
		fields = append(fields, friendship.FieldFriendUserID)
	}
	if m.created_at != nil {
		fields = append(fields, friendship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendship.FieldUserID:
		return m.UserID()
	case friendship.FieldFriendUserID:
		return m.FriendUserID()
	case friendship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendship.FieldUserID:
		return m.OldUserID(ctx)
	case friendship.FieldFriendUserID:
		return m.OldFriendUserID(ctx)
	case friendship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Friendship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendship.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case friendship.FieldFriendUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendUserID(v)
		return nil
	case friendship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Friendship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Friendship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipMutation) ResetField(name string) error {
	switch name {
	case friendship.FieldUserID:
		m.ResetUserID()
		return nil
	case friendship.FieldFriendUserID:
		m.ResetFriendUserID()
		return nil
	case friendship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.friend_user != nil {
		edges = append(edges, friendship.EdgeFriendUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendship.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case friendship.EdgeFriendUser:
		if id := m.friend_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.clearedfriend_user {
		edges = append(edges, friendship.EdgeFriendUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipMutation) EdgeCleared(name string) bool {
	switch name {
	case friendship.EdgeUser:
		return m.cleareduser
	case friendship.EdgeFriendUser:
		return m.clearedfriend_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipMutation) ClearEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ClearUser()
		return nil
	case friendship.EdgeFriendUser:
		m.ClearFriendUser()
		return nil
	}
	return fmt.Errorf("unknown Friendship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipMutation) ResetEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ResetUser()
		return nil
	case friendship.EdgeFriendUser:
		m.ResetFriendUser()
		return nil
	}
	return fmt.Errorf("unknown Friendship edge %s", name)
}

// FriendshipRequestMutation represents an operation that mutates the FriendshipRequest nodes in the graph.
type FriendshipRequestMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	from_users        *uuid.UUID
	clearedfrom_users bool
	to_users          *uuid.UUID
	clearedto_users   bool
	done              bool
	oldValue          func(context.Context) (*FriendshipRequest, error)
	predicates        []predicate.FriendshipRequest
}

var _ ent.Mutation = (*FriendshipRequestMutation)(nil)

// friendshiprequestOption allows management of the mutation configuration using functional options.
type friendshiprequestOption func(*FriendshipRequestMutation)

// newFriendshipRequestMutation creates new mutation for the FriendshipRequest entity.
func newFriendshipRequestMutation(c config, op Op, opts ...friendshiprequestOption) *FriendshipRequestMutation {
	m := &FriendshipRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendshipRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipRequestID sets the ID field of the mutation.
func withFriendshipRequestID(id uuid.UUID) friendshiprequestOption {
	return func(m *FriendshipRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendshipRequest
		)
		m.oldValue = func(ctx context.Context) (*FriendshipRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendshipRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendshipRequest sets the old FriendshipRequest of the mutation.
func withFriendshipRequest(node *FriendshipRequest) friendshiprequestOption {
	return func(m *FriendshipRequestMutation) {
		m.oldValue = func(context.Context) (*FriendshipRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendshipRequest entities.
func (m *FriendshipRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendshipRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromUserID sets the "from_user_id" field.
func (m *FriendshipRequestMutation) SetFromUserID(u uuid.UUID) {
	m.from_users = &u
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *FriendshipRequestMutation) FromUserID() (r uuid.UUID, exists bool) {
	v := m.from_users
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldFromUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *FriendshipRequestMutation) ResetFromUserID() {
	m.from_users = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *FriendshipRequestMutation) SetToUserID(u uuid.UUID) {
	m.to_users = &u
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *FriendshipRequestMutation) ToUserID() (r uuid.UUID, exists bool) {
	v := m.to_users
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldToUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *FriendshipRequestMutation) ResetToUserID() {
	m.to_users = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendshipRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendshipRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendshipRequest entity.
// If the FriendshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendshipRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetFromUsersID sets the "from_users" edge to the User entity by id.
func (m *FriendshipRequestMutation) SetFromUsersID(id uuid.UUID) {
	m.from_users = &id
}

// ClearFromUsers clears the "from_users" edge to the User entity.
func (m *FriendshipRequestMutation) ClearFromUsers() {
	m.clearedfrom_users = true
}

// FromUsersCleared reports if the "from_users" edge to the User entity was cleared.
func (m *FriendshipRequestMutation) FromUsersCleared() bool {
	return m.clearedfrom_users
}

// FromUsersID returns the "from_users" edge ID in the mutation.
func (m *FriendshipRequestMutation) FromUsersID() (id uuid.UUID, exists bool) {
	if m.from_users != nil {
		return *m.from_users, true
	}
	return
}

// FromUsersIDs returns the "from_users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromUsersID instead. It exists only for internal usage by the builders.
func (m *FriendshipRequestMutation) FromUsersIDs() (ids []uuid.UUID) {
	if id := m.from_users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromUsers resets all changes to the "from_users" edge.
func (m *FriendshipRequestMutation) ResetFromUsers() {
	m.from_users = nil
	m.clearedfrom_users = false
}

// SetToUsersID sets the "to_users" edge to the User entity by id.
func (m *FriendshipRequestMutation) SetToUsersID(id uuid.UUID) {
	m.to_users = &id
}

// ClearToUsers clears the "to_users" edge to the User entity.
func (m *FriendshipRequestMutation) ClearToUsers() {
	m.clearedto_users = true
}

// ToUsersCleared reports if the "to_users" edge to the User entity was cleared.
func (m *FriendshipRequestMutation) ToUsersCleared() bool {
	return m.clearedto_users
}

// ToUsersID returns the "to_users" edge ID in the mutation.
func (m *FriendshipRequestMutation) ToUsersID() (id uuid.UUID, exists bool) {
	if m.to_users != nil {
		return *m.to_users, true
	}
	return
}

// ToUsersIDs returns the "to_users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToUsersID instead. It exists only for internal usage by the builders.
func (m *FriendshipRequestMutation) ToUsersIDs() (ids []uuid.UUID) {
	if id := m.to_users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToUsers resets all changes to the "to_users" edge.
func (m *FriendshipRequestMutation) ResetToUsers() {
	m.to_users = nil
	m.clearedto_users = false
}

// Where appends a list predicates to the FriendshipRequestMutation builder.
func (m *FriendshipRequestMutation) Where(ps ...predicate.FriendshipRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendshipRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendshipRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FriendshipRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendshipRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendshipRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FriendshipRequest).
func (m *FriendshipRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipRequestMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.from_users != nil {
		fields = append(fields, friendshiprequest.FieldFromUserID)
	}
	if m.to_users != nil {
		fields = append(fields, friendshiprequest.FieldToUserID)
	}
	if m.created_at != nil {
		fields = append(fields, friendshiprequest.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendshiprequest.FieldFromUserID:
		return m.FromUserID()
	case friendshiprequest.FieldToUserID:
		return m.ToUserID()
	case friendshiprequest.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendshiprequest.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case friendshiprequest.FieldToUserID:
		return m.OldToUserID(ctx)
	case friendshiprequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendshiprequest.FieldFromUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case friendshiprequest.FieldToUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case friendshiprequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FriendshipRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FriendshipRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipRequestMutation) ResetField(name string) error {
	switch name {
	case friendshiprequest.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case friendshiprequest.FieldToUserID:
		m.ResetToUserID()
		return nil
	case friendshiprequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_users != nil {
		edges = append(edges, friendshiprequest.EdgeFromUsers)
	}
	if m.to_users != nil {
		edges = append(edges, friendshiprequest.EdgeToUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		if id := m.from_users; id != nil {
			return []ent.Value{*id}
		}
	case friendshiprequest.EdgeToUsers:
		if id := m.to_users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_users {
		edges = append(edges, friendshiprequest.EdgeFromUsers)
	}
	if m.clearedto_users {
		edges = append(edges, friendshiprequest.EdgeToUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		return m.clearedfrom_users
	case friendshiprequest.EdgeToUsers:
		return m.clearedto_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipRequestMutation) ClearEdge(name string) error {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		m.ClearFromUsers()
		return nil
	case friendshiprequest.EdgeToUsers:
		m.ClearToUsers()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipRequestMutation) ResetEdge(name string) error {
	switch name {
	case friendshiprequest.EdgeFromUsers:
		m.ResetFromUsers()
		return nil
	case friendshiprequest.EdgeToUsers:
		m.ResetToUsers()
		return nil
	}
	return fmt.Errorf("unknown FriendshipRequest edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	location                      *string
	coordinate                    **pgutil.GeoPoint
	comment                       *string
	starts_at                     *time.Time
	expires_at                    *time.Time
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	user                          *uuid.UUID
	cleareduser                   bool
	invitation_users              map[uuid.UUID]struct{}
	removedinvitation_users       map[uuid.UUID]struct{}
	clearedinvitation_users       bool
	invitation_acceptances        map[uuid.UUID]struct{}
	removedinvitation_acceptances map[uuid.UUID]struct{}
	clearedinvitation_acceptances bool
	invitation_denials            map[uuid.UUID]struct{}
	removedinvitation_denials     map[uuid.UUID]struct{}
	clearedinvitation_denials     bool
	done                          bool
	oldValue                      func(context.Context) (*Invitation, error)
	predicates                    []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id uuid.UUID) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invitation entities.
func (m *InvitationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationMutation) ResetUserID() {
	m.user = nil
}

// SetLocation sets the "location" field.
func (m *InvitationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *InvitationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *InvitationMutation) ResetLocation() {
	m.location = nil
}

// SetCoordinate sets the "coordinate" field.
func (m *InvitationMutation) SetCoordinate(pp *pgutil.GeoPoint) {
	m.coordinate = &pp
}

// Coordinate returns the value of the "coordinate" field in the mutation.
func (m *InvitationMutation) Coordinate() (r *pgutil.GeoPoint, exists bool) {
	v := m.coordinate
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinate returns the old "coordinate" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCoordinate(ctx context.Context) (v *pgutil.GeoPoint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinate: %w", err)
	}
	return oldValue.Coordinate, nil
}

// ResetCoordinate resets all changes to the "coordinate" field.
func (m *InvitationMutation) ResetCoordinate() {
	m.coordinate = nil
}

// SetComment sets the "comment" field.
func (m *InvitationMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InvitationMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *InvitationMutation) ResetComment() {
	m.comment = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *InvitationMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *InvitationMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *InvitationMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *InvitationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *InvitationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *InvitationMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddInvitationUserIDs adds the "invitation_users" edge to the InvitationUser entity by ids.
func (m *InvitationMutation) AddInvitationUserIDs(ids ...uuid.UUID) {
	if m.invitation_users == nil {
		m.invitation_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_users[ids[i]] = struct{}{}
	}
}

// ClearInvitationUsers clears the "invitation_users" edge to the InvitationUser entity.
func (m *InvitationMutation) ClearInvitationUsers() {
	m.clearedinvitation_users = true
}

// InvitationUsersCleared reports if the "invitation_users" edge to the InvitationUser entity was cleared.
func (m *InvitationMutation) InvitationUsersCleared() bool {
	return m.clearedinvitation_users
}

// RemoveInvitationUserIDs removes the "invitation_users" edge to the InvitationUser entity by IDs.
func (m *InvitationMutation) RemoveInvitationUserIDs(ids ...uuid.UUID) {
	if m.removedinvitation_users == nil {
		m.removedinvitation_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_users, ids[i])
		m.removedinvitation_users[ids[i]] = struct{}{}
	}
}

// RemovedInvitationUsers returns the removed IDs of the "invitation_users" edge to the InvitationUser entity.
func (m *InvitationMutation) RemovedInvitationUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_users {
		ids = append(ids, id)
	}
	return
}

// InvitationUsersIDs returns the "invitation_users" edge IDs in the mutation.
func (m *InvitationMutation) InvitationUsersIDs() (ids []uuid.UUID) {
	for id := range m.invitation_users {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationUsers resets all changes to the "invitation_users" edge.
func (m *InvitationMutation) ResetInvitationUsers() {
	m.invitation_users = nil
	m.clearedinvitation_users = false
	m.removedinvitation_users = nil
}

// AddInvitationAcceptanceIDs adds the "invitation_acceptances" edge to the InvitationAcceptance entity by ids.
func (m *InvitationMutation) AddInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.invitation_acceptances == nil {
		m.invitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_acceptances[ids[i]] = struct{}{}
	}
}

// ClearInvitationAcceptances clears the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *InvitationMutation) ClearInvitationAcceptances() {
	m.clearedinvitation_acceptances = true
}

// InvitationAcceptancesCleared reports if the "invitation_acceptances" edge to the InvitationAcceptance entity was cleared.
func (m *InvitationMutation) InvitationAcceptancesCleared() bool {
	return m.clearedinvitation_acceptances
}

// RemoveInvitationAcceptanceIDs removes the "invitation_acceptances" edge to the InvitationAcceptance entity by IDs.
func (m *InvitationMutation) RemoveInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.removedinvitation_acceptances == nil {
		m.removedinvitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_acceptances, ids[i])
		m.removedinvitation_acceptances[ids[i]] = struct{}{}
	}
}

// RemovedInvitationAcceptances returns the removed IDs of the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *InvitationMutation) RemovedInvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// InvitationAcceptancesIDs returns the "invitation_acceptances" edge IDs in the mutation.
func (m *InvitationMutation) InvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.invitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationAcceptances resets all changes to the "invitation_acceptances" edge.
func (m *InvitationMutation) ResetInvitationAcceptances() {
	m.invitation_acceptances = nil
	m.clearedinvitation_acceptances = false
	m.removedinvitation_acceptances = nil
}

// AddInvitationDenialIDs adds the "invitation_denials" edge to the InvitationDenial entity by ids.
func (m *InvitationMutation) AddInvitationDenialIDs(ids ...uuid.UUID) {
	if m.invitation_denials == nil {
		m.invitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_denials[ids[i]] = struct{}{}
	}
}

// ClearInvitationDenials clears the "invitation_denials" edge to the InvitationDenial entity.
func (m *InvitationMutation) ClearInvitationDenials() {
	m.clearedinvitation_denials = true
}

// InvitationDenialsCleared reports if the "invitation_denials" edge to the InvitationDenial entity was cleared.
func (m *InvitationMutation) InvitationDenialsCleared() bool {
	return m.clearedinvitation_denials
}

// RemoveInvitationDenialIDs removes the "invitation_denials" edge to the InvitationDenial entity by IDs.
func (m *InvitationMutation) RemoveInvitationDenialIDs(ids ...uuid.UUID) {
	if m.removedinvitation_denials == nil {
		m.removedinvitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_denials, ids[i])
		m.removedinvitation_denials[ids[i]] = struct{}{}
	}
}

// RemovedInvitationDenials returns the removed IDs of the "invitation_denials" edge to the InvitationDenial entity.
func (m *InvitationMutation) RemovedInvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_denials {
		ids = append(ids, id)
	}
	return
}

// InvitationDenialsIDs returns the "invitation_denials" edge IDs in the mutation.
func (m *InvitationMutation) InvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_denials {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationDenials resets all changes to the "invitation_denials" edge.
func (m *InvitationMutation) ResetInvitationDenials() {
	m.invitation_denials = nil
	m.clearedinvitation_denials = false
	m.removedinvitation_denials = nil
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user != nil {
		fields = append(fields, invitation.FieldUserID)
	}
	if m.location != nil {
		fields = append(fields, invitation.FieldLocation)
	}
	if m.coordinate != nil {
		fields = append(fields, invitation.FieldCoordinate)
	}
	if m.comment != nil {
		fields = append(fields, invitation.FieldComment)
	}
	if m.starts_at != nil {
		fields = append(fields, invitation.FieldStartsAt)
	}
	if m.expires_at != nil {
		fields = append(fields, invitation.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, invitation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldUserID:
		return m.UserID()
	case invitation.FieldLocation:
		return m.Location()
	case invitation.FieldCoordinate:
		return m.Coordinate()
	case invitation.FieldComment:
		return m.Comment()
	case invitation.FieldStartsAt:
		return m.StartsAt()
	case invitation.FieldExpiresAt:
		return m.ExpiresAt()
	case invitation.FieldCreatedAt:
		return m.CreatedAt()
	case invitation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldUserID:
		return m.OldUserID(ctx)
	case invitation.FieldLocation:
		return m.OldLocation(ctx)
	case invitation.FieldCoordinate:
		return m.OldCoordinate(ctx)
	case invitation.FieldComment:
		return m.OldComment(ctx)
	case invitation.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case invitation.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case invitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case invitation.FieldCoordinate:
		v, ok := value.(*pgutil.GeoPoint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinate(v)
		return nil
	case invitation.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case invitation.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case invitation.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case invitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldUserID:
		m.ResetUserID()
		return nil
	case invitation.FieldLocation:
		m.ResetLocation()
		return nil
	case invitation.FieldCoordinate:
		m.ResetCoordinate()
		return nil
	case invitation.FieldComment:
		m.ResetComment()
		return nil
	case invitation.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case invitation.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case invitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, invitation.EdgeUser)
	}
	if m.invitation_users != nil {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.invitation_acceptances != nil {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.invitation_denials != nil {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitation.EdgeInvitationUsers:
		ids := make([]ent.Value, 0, len(m.invitation_users))
		for id := range m.invitation_users {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.invitation_acceptances))
		for id := range m.invitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.invitation_denials))
		for id := range m.invitation_denials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinvitation_users != nil {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.removedinvitation_acceptances != nil {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.removedinvitation_denials != nil {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeInvitationUsers:
		ids := make([]ent.Value, 0, len(m.removedinvitation_users))
		for id := range m.removedinvitation_users {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.removedinvitation_acceptances))
		for id := range m.removedinvitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case invitation.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.removedinvitation_denials))
		for id := range m.removedinvitation_denials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, invitation.EdgeUser)
	}
	if m.clearedinvitation_users {
		edges = append(edges, invitation.EdgeInvitationUsers)
	}
	if m.clearedinvitation_acceptances {
		edges = append(edges, invitation.EdgeInvitationAcceptances)
	}
	if m.clearedinvitation_denials {
		edges = append(edges, invitation.EdgeInvitationDenials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeUser:
		return m.cleareduser
	case invitation.EdgeInvitationUsers:
		return m.clearedinvitation_users
	case invitation.EdgeInvitationAcceptances:
		return m.clearedinvitation_acceptances
	case invitation.EdgeInvitationDenials:
		return m.clearedinvitation_denials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeUser:
		m.ResetUser()
		return nil
	case invitation.EdgeInvitationUsers:
		m.ResetInvitationUsers()
		return nil
	case invitation.EdgeInvitationAcceptances:
		m.ResetInvitationAcceptances()
		return nil
	case invitation.EdgeInvitationDenials:
		m.ResetInvitationDenials()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// InvitationAcceptanceMutation represents an operation that mutates the InvitationAcceptance nodes in the graph.
type InvitationAcceptanceMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	invitation        *uuid.UUID
	clearedinvitation bool
	done              bool
	oldValue          func(context.Context) (*InvitationAcceptance, error)
	predicates        []predicate.InvitationAcceptance
}

var _ ent.Mutation = (*InvitationAcceptanceMutation)(nil)

// invitationacceptanceOption allows management of the mutation configuration using functional options.
type invitationacceptanceOption func(*InvitationAcceptanceMutation)

// newInvitationAcceptanceMutation creates new mutation for the InvitationAcceptance entity.
func newInvitationAcceptanceMutation(c config, op Op, opts ...invitationacceptanceOption) *InvitationAcceptanceMutation {
	m := &InvitationAcceptanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationAcceptance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationAcceptanceID sets the ID field of the mutation.
func withInvitationAcceptanceID(id uuid.UUID) invitationacceptanceOption {
	return func(m *InvitationAcceptanceMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationAcceptance
		)
		m.oldValue = func(ctx context.Context) (*InvitationAcceptance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationAcceptance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationAcceptance sets the old InvitationAcceptance of the mutation.
func withInvitationAcceptance(node *InvitationAcceptance) invitationacceptanceOption {
	return func(m *InvitationAcceptanceMutation) {
		m.oldValue = func(context.Context) (*InvitationAcceptance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationAcceptanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationAcceptanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationAcceptance entities.
func (m *InvitationAcceptanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationAcceptanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationAcceptanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationAcceptance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationAcceptanceMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationAcceptanceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationAcceptanceMutation) ResetUserID() {
	m.user = nil
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationAcceptanceMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationAcceptanceMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationAcceptanceMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationAcceptanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationAcceptanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationAcceptance entity.
// If the InvitationAcceptance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationAcceptanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationAcceptanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationAcceptanceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationAcceptanceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationAcceptanceMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationAcceptanceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationAcceptanceMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationAcceptanceMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationAcceptanceMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationAcceptanceMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// Where appends a list predicates to the InvitationAcceptanceMutation builder.
func (m *InvitationAcceptanceMutation) Where(ps ...predicate.InvitationAcceptance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationAcceptanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationAcceptanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvitationAcceptance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationAcceptanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationAcceptanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvitationAcceptance).
func (m *InvitationAcceptanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationAcceptanceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, invitationacceptance.FieldUserID)
	}
	if m.invitation != nil {
		fields = append(fields, invitationacceptance.FieldInvitationID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationacceptance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationAcceptanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationacceptance.FieldUserID:
		return m.UserID()
	case invitationacceptance.FieldInvitationID:
		return m.InvitationID()
	case invitationacceptance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationAcceptanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationacceptance.FieldUserID:
		return m.OldUserID(ctx)
	case invitationacceptance.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationacceptance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationAcceptanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationacceptance.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationacceptance.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationacceptance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationAcceptanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationAcceptanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationAcceptanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationAcceptance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationAcceptanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationAcceptanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationAcceptanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationAcceptance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationAcceptanceMutation) ResetField(name string) error {
	switch name {
	case invitationacceptance.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationacceptance.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationacceptance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationAcceptanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, invitationacceptance.EdgeUser)
	}
	if m.invitation != nil {
		edges = append(edges, invitationacceptance.EdgeInvitation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationAcceptanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationacceptance.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitationacceptance.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationAcceptanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationAcceptanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationAcceptanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, invitationacceptance.EdgeUser)
	}
	if m.clearedinvitation {
		edges = append(edges, invitationacceptance.EdgeInvitation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationAcceptanceMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationacceptance.EdgeUser:
		return m.cleareduser
	case invitationacceptance.EdgeInvitation:
		return m.clearedinvitation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationAcceptanceMutation) ClearEdge(name string) error {
	switch name {
	case invitationacceptance.EdgeUser:
		m.ClearUser()
		return nil
	case invitationacceptance.EdgeInvitation:
		m.ClearInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationAcceptanceMutation) ResetEdge(name string) error {
	switch name {
	case invitationacceptance.EdgeUser:
		m.ResetUser()
		return nil
	case invitationacceptance.EdgeInvitation:
		m.ResetInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationAcceptance edge %s", name)
}

// InvitationDenialMutation represents an operation that mutates the InvitationDenial nodes in the graph.
type InvitationDenialMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	invitation        *uuid.UUID
	clearedinvitation bool
	done              bool
	oldValue          func(context.Context) (*InvitationDenial, error)
	predicates        []predicate.InvitationDenial
}

var _ ent.Mutation = (*InvitationDenialMutation)(nil)

// invitationdenialOption allows management of the mutation configuration using functional options.
type invitationdenialOption func(*InvitationDenialMutation)

// newInvitationDenialMutation creates new mutation for the InvitationDenial entity.
func newInvitationDenialMutation(c config, op Op, opts ...invitationdenialOption) *InvitationDenialMutation {
	m := &InvitationDenialMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationDenial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationDenialID sets the ID field of the mutation.
func withInvitationDenialID(id uuid.UUID) invitationdenialOption {
	return func(m *InvitationDenialMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationDenial
		)
		m.oldValue = func(ctx context.Context) (*InvitationDenial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationDenial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationDenial sets the old InvitationDenial of the mutation.
func withInvitationDenial(node *InvitationDenial) invitationdenialOption {
	return func(m *InvitationDenialMutation) {
		m.oldValue = func(context.Context) (*InvitationDenial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationDenialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationDenialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationDenial entities.
func (m *InvitationDenialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationDenialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationDenialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationDenial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InvitationDenialMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationDenialMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationDenialMutation) ResetUserID() {
	m.user = nil
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationDenialMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationDenialMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationDenialMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationDenialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationDenialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationDenial entity.
// If the InvitationDenial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationDenialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationDenialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationDenialMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationDenialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationDenialMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationDenialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationDenialMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationDenialMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationDenialMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationDenialMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// Where appends a list predicates to the InvitationDenialMutation builder.
func (m *InvitationDenialMutation) Where(ps ...predicate.InvitationDenial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationDenialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationDenialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvitationDenial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationDenialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationDenialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvitationDenial).
func (m *InvitationDenialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationDenialMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, invitationdenial.FieldUserID)
	}
	if m.invitation != nil {
		fields = append(fields, invitationdenial.FieldInvitationID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationdenial.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationDenialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationdenial.FieldUserID:
		return m.UserID()
	case invitationdenial.FieldInvitationID:
		return m.InvitationID()
	case invitationdenial.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationDenialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationdenial.FieldUserID:
		return m.OldUserID(ctx)
	case invitationdenial.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationdenial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationDenial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationDenialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationdenial.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationdenial.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationdenial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationDenialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationDenialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationDenialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationDenial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationDenialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationDenialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationDenialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationDenial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationDenialMutation) ResetField(name string) error {
	switch name {
	case invitationdenial.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationdenial.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationdenial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationDenialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, invitationdenial.EdgeUser)
	}
	if m.invitation != nil {
		edges = append(edges, invitationdenial.EdgeInvitation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationDenialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationdenial.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case invitationdenial.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationDenialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationDenialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationDenialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, invitationdenial.EdgeUser)
	}
	if m.clearedinvitation {
		edges = append(edges, invitationdenial.EdgeInvitation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationDenialMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationdenial.EdgeUser:
		return m.cleareduser
	case invitationdenial.EdgeInvitation:
		return m.clearedinvitation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationDenialMutation) ClearEdge(name string) error {
	switch name {
	case invitationdenial.EdgeUser:
		m.ClearUser()
		return nil
	case invitationdenial.EdgeInvitation:
		m.ClearInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationDenialMutation) ResetEdge(name string) error {
	switch name {
	case invitationdenial.EdgeUser:
		m.ResetUser()
		return nil
	case invitationdenial.EdgeInvitation:
		m.ResetInvitation()
		return nil
	}
	return fmt.Errorf("unknown InvitationDenial edge %s", name)
}

// InvitationUserMutation represents an operation that mutates the InvitationUser nodes in the graph.
type InvitationUserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	invitation        *uuid.UUID
	clearedinvitation bool
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*InvitationUser, error)
	predicates        []predicate.InvitationUser
}

var _ ent.Mutation = (*InvitationUserMutation)(nil)

// invitationuserOption allows management of the mutation configuration using functional options.
type invitationuserOption func(*InvitationUserMutation)

// newInvitationUserMutation creates new mutation for the InvitationUser entity.
func newInvitationUserMutation(c config, op Op, opts ...invitationuserOption) *InvitationUserMutation {
	m := &InvitationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationUserID sets the ID field of the mutation.
func withInvitationUserID(id uuid.UUID) invitationuserOption {
	return func(m *InvitationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationUser
		)
		m.oldValue = func(ctx context.Context) (*InvitationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationUser sets the old InvitationUser of the mutation.
func withInvitationUser(node *InvitationUser) invitationuserOption {
	return func(m *InvitationUserMutation) {
		m.oldValue = func(context.Context) (*InvitationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationUser entities.
func (m *InvitationUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvitationID sets the "invitation_id" field.
func (m *InvitationUserMutation) SetInvitationID(u uuid.UUID) {
	m.invitation = &u
}

// InvitationID returns the value of the "invitation_id" field in the mutation.
func (m *InvitationUserMutation) InvitationID() (r uuid.UUID, exists bool) {
	v := m.invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationID returns the old "invitation_id" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldInvitationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationID: %w", err)
	}
	return oldValue.InvitationID, nil
}

// ResetInvitationID resets all changes to the "invitation_id" field.
func (m *InvitationUserMutation) ResetInvitationID() {
	m.invitation = nil
}

// SetUserID sets the "user_id" field.
func (m *InvitationUserMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationUserMutation) ResetUserID() {
	m.user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationUser entity.
// If the InvitationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearInvitation clears the "invitation" edge to the Invitation entity.
func (m *InvitationUserMutation) ClearInvitation() {
	m.clearedinvitation = true
}

// InvitationCleared reports if the "invitation" edge to the Invitation entity was cleared.
func (m *InvitationUserMutation) InvitationCleared() bool {
	return m.clearedinvitation
}

// InvitationIDs returns the "invitation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvitationID instead. It exists only for internal usage by the builders.
func (m *InvitationUserMutation) InvitationIDs() (ids []uuid.UUID) {
	if id := m.invitation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitation resets all changes to the "invitation" edge.
func (m *InvitationUserMutation) ResetInvitation() {
	m.invitation = nil
	m.clearedinvitation = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *InvitationUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InvitationUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InvitationUserMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InvitationUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the InvitationUserMutation builder.
func (m *InvitationUserMutation) Where(ps ...predicate.InvitationUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvitationUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvitationUser).
func (m *InvitationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.invitation != nil {
		fields = append(fields, invitationuser.FieldInvitationID)
	}
	if m.user != nil {
		fields = append(fields, invitationuser.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, invitationuser.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationuser.FieldInvitationID:
		return m.InvitationID()
	case invitationuser.FieldUserID:
		return m.UserID()
	case invitationuser.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationuser.FieldInvitationID:
		return m.OldInvitationID(ctx)
	case invitationuser.FieldUserID:
		return m.OldUserID(ctx)
	case invitationuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationuser.FieldInvitationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationID(v)
		return nil
	case invitationuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvitationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvitationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationUserMutation) ResetField(name string) error {
	switch name {
	case invitationuser.FieldInvitationID:
		m.ResetInvitationID()
		return nil
	case invitationuser.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invitation != nil {
		edges = append(edges, invitationuser.EdgeInvitation)
	}
	if m.user != nil {
		edges = append(edges, invitationuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitationuser.EdgeInvitation:
		if id := m.invitation; id != nil {
			return []ent.Value{*id}
		}
	case invitationuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvitation {
		edges = append(edges, invitationuser.EdgeInvitation)
	}
	if m.cleareduser {
		edges = append(edges, invitationuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationUserMutation) EdgeCleared(name string) bool {
	switch name {
	case invitationuser.EdgeInvitation:
		return m.clearedinvitation
	case invitationuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationUserMutation) ClearEdge(name string) error {
	switch name {
	case invitationuser.EdgeInvitation:
		m.ClearInvitation()
		return nil
	case invitationuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationUserMutation) ResetEdge(name string) error {
	switch name {
	case invitationuser.EdgeInvitation:
		m.ResetInvitation()
		return nil
	case invitationuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown InvitationUser edge %s", name)
}

// PushNotificationTokenMutation represents an operation that mutates the PushNotificationToken nodes in the graph.
type PushNotificationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	device_id     *string
	fcm_token     *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PushNotificationToken, error)
	predicates    []predicate.PushNotificationToken
}

var _ ent.Mutation = (*PushNotificationTokenMutation)(nil)

// pushnotificationtokenOption allows management of the mutation configuration using functional options.
type pushnotificationtokenOption func(*PushNotificationTokenMutation)

// newPushNotificationTokenMutation creates new mutation for the PushNotificationToken entity.
func newPushNotificationTokenMutation(c config, op Op, opts ...pushnotificationtokenOption) *PushNotificationTokenMutation {
	m := &PushNotificationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePushNotificationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPushNotificationTokenID sets the ID field of the mutation.
func withPushNotificationTokenID(id uuid.UUID) pushnotificationtokenOption {
	return func(m *PushNotificationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PushNotificationToken
		)
		m.oldValue = func(ctx context.Context) (*PushNotificationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PushNotificationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPushNotificationToken sets the old PushNotificationToken of the mutation.
func withPushNotificationToken(node *PushNotificationToken) pushnotificationtokenOption {
	return func(m *PushNotificationTokenMutation) {
		m.oldValue = func(context.Context) (*PushNotificationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PushNotificationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PushNotificationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PushNotificationToken entities.
func (m *PushNotificationTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PushNotificationTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PushNotificationTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PushNotificationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PushNotificationTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PushNotificationTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PushNotificationToken entity.
// If the PushNotificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushNotificationTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PushNotificationTokenMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *PushNotificationTokenMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *PushNotificationTokenMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the PushNotificationToken entity.
// If the PushNotificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushNotificationTokenMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *PushNotificationTokenMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetFcmToken sets the "fcm_token" field.
func (m *PushNotificationTokenMutation) SetFcmToken(s string) {
	m.fcm_token = &s
}

// FcmToken returns the value of the "fcm_token" field in the mutation.
func (m *PushNotificationTokenMutation) FcmToken() (r string, exists bool) {
	v := m.fcm_token
	if v == nil {
		return
	}
	return *v, true
}

// OldFcmToken returns the old "fcm_token" field's value of the PushNotificationToken entity.
// If the PushNotificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushNotificationTokenMutation) OldFcmToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcmToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcmToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcmToken: %w", err)
	}
	return oldValue.FcmToken, nil
}

// ResetFcmToken resets all changes to the "fcm_token" field.
func (m *PushNotificationTokenMutation) ResetFcmToken() {
	m.fcm_token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PushNotificationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PushNotificationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PushNotificationToken entity.
// If the PushNotificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushNotificationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PushNotificationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PushNotificationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PushNotificationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PushNotificationToken entity.
// If the PushNotificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushNotificationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PushNotificationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PushNotificationTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PushNotificationTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PushNotificationTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PushNotificationTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PushNotificationTokenMutation builder.
func (m *PushNotificationTokenMutation) Where(ps ...predicate.PushNotificationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PushNotificationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PushNotificationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PushNotificationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PushNotificationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PushNotificationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PushNotificationToken).
func (m *PushNotificationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PushNotificationTokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, pushnotificationtoken.FieldUserID)
	}
	if m.device_id != nil {
		fields = append(fields, pushnotificationtoken.FieldDeviceID)
	}
	if m.fcm_token != nil {
		fields = append(fields, pushnotificationtoken.FieldFcmToken)
	}
	if m.created_at != nil {
		fields = append(fields, pushnotificationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pushnotificationtoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PushNotificationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pushnotificationtoken.FieldUserID:
		return m.UserID()
	case pushnotificationtoken.FieldDeviceID:
		return m.DeviceID()
	case pushnotificationtoken.FieldFcmToken:
		return m.FcmToken()
	case pushnotificationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case pushnotificationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PushNotificationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pushnotificationtoken.FieldUserID:
		return m.OldUserID(ctx)
	case pushnotificationtoken.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case pushnotificationtoken.FieldFcmToken:
		return m.OldFcmToken(ctx)
	case pushnotificationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pushnotificationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PushNotificationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PushNotificationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pushnotificationtoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case pushnotificationtoken.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case pushnotificationtoken.FieldFcmToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcmToken(v)
		return nil
	case pushnotificationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pushnotificationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PushNotificationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PushNotificationTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PushNotificationTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PushNotificationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PushNotificationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PushNotificationTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PushNotificationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PushNotificationTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PushNotificationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PushNotificationTokenMutation) ResetField(name string) error {
	switch name {
	case pushnotificationtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case pushnotificationtoken.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case pushnotificationtoken.FieldFcmToken:
		m.ResetFcmToken()
		return nil
	case pushnotificationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pushnotificationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PushNotificationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PushNotificationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, pushnotificationtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PushNotificationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pushnotificationtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PushNotificationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PushNotificationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PushNotificationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, pushnotificationtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PushNotificationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case pushnotificationtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PushNotificationTokenMutation) ClearEdge(name string) error {
	switch name {
	case pushnotificationtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PushNotificationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PushNotificationTokenMutation) ResetEdge(name string) error {
	switch name {
	case pushnotificationtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PushNotificationToken edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	clearedFields                   map[string]struct{}
	account                         *uuid.UUID
	clearedaccount                  bool
	user_profile                    *uuid.UUID
	cleareduser_profile             bool
	friend_users                    map[uuid.UUID]struct{}
	removedfriend_users             map[uuid.UUID]struct{}
	clearedfriend_users             bool
	push_notification_tokens        map[uuid.UUID]struct{}
	removedpush_notification_tokens map[uuid.UUID]struct{}
	clearedpush_notification_tokens bool
	friend_groups                   map[uuid.UUID]struct{}
	removedfriend_groups            map[uuid.UUID]struct{}
	clearedfriend_groups            bool
	belonging_friend_groups         map[uuid.UUID]struct{}
	removedbelonging_friend_groups  map[uuid.UUID]struct{}
	clearedbelonging_friend_groups  bool
	invitation_acceptances          map[uuid.UUID]struct{}
	removedinvitation_acceptances   map[uuid.UUID]struct{}
	clearedinvitation_acceptances   bool
	invitation_denials              map[uuid.UUID]struct{}
	removedinvitation_denials       map[uuid.UUID]struct{}
	clearedinvitation_denials       bool
	friendships                     map[uuid.UUID]struct{}
	removedfriendships              map[uuid.UUID]struct{}
	clearedfriendships              bool
	user_friend_groups              map[uuid.UUID]struct{}
	removeduser_friend_groups       map[uuid.UUID]struct{}
	cleareduser_friend_groups       bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *UserMutation) SetAccountID(u uuid.UUID) {
	m.account = &u
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *UserMutation) AccountID() (r uuid.UUID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *UserMutation) ResetAccountID() {
	m.account = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *UserMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *UserMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetUserProfileID sets the "user_profile" edge to the UserProfile entity by id.
func (m *UserMutation) SetUserProfileID(id uuid.UUID) {
	m.user_profile = &id
}

// ClearUserProfile clears the "user_profile" edge to the UserProfile entity.
func (m *UserMutation) ClearUserProfile() {
	m.cleareduser_profile = true
}

// UserProfileCleared reports if the "user_profile" edge to the UserProfile entity was cleared.
func (m *UserMutation) UserProfileCleared() bool {
	return m.cleareduser_profile
}

// UserProfileID returns the "user_profile" edge ID in the mutation.
func (m *UserMutation) UserProfileID() (id uuid.UUID, exists bool) {
	if m.user_profile != nil {
		return *m.user_profile, true
	}
	return
}

// UserProfileIDs returns the "user_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserProfileIDs() (ids []uuid.UUID) {
	if id := m.user_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserProfile resets all changes to the "user_profile" edge.
func (m *UserMutation) ResetUserProfile() {
	m.user_profile = nil
	m.cleareduser_profile = false
}

// AddFriendUserIDs adds the "friend_users" edge to the User entity by ids.
func (m *UserMutation) AddFriendUserIDs(ids ...uuid.UUID) {
	if m.friend_users == nil {
		m.friend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_users[ids[i]] = struct{}{}
	}
}

// ClearFriendUsers clears the "friend_users" edge to the User entity.
func (m *UserMutation) ClearFriendUsers() {
	m.clearedfriend_users = true
}

// FriendUsersCleared reports if the "friend_users" edge to the User entity was cleared.
func (m *UserMutation) FriendUsersCleared() bool {
	return m.clearedfriend_users
}

// RemoveFriendUserIDs removes the "friend_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveFriendUserIDs(ids ...uuid.UUID) {
	if m.removedfriend_users == nil {
		m.removedfriend_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_users, ids[i])
		m.removedfriend_users[ids[i]] = struct{}{}
	}
}

// RemovedFriendUsers returns the removed IDs of the "friend_users" edge to the User entity.
func (m *UserMutation) RemovedFriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_users {
		ids = append(ids, id)
	}
	return
}

// FriendUsersIDs returns the "friend_users" edge IDs in the mutation.
func (m *UserMutation) FriendUsersIDs() (ids []uuid.UUID) {
	for id := range m.friend_users {
		ids = append(ids, id)
	}
	return
}

// ResetFriendUsers resets all changes to the "friend_users" edge.
func (m *UserMutation) ResetFriendUsers() {
	m.friend_users = nil
	m.clearedfriend_users = false
	m.removedfriend_users = nil
}

// AddPushNotificationTokenIDs adds the "push_notification_tokens" edge to the PushNotificationToken entity by ids.
func (m *UserMutation) AddPushNotificationTokenIDs(ids ...uuid.UUID) {
	if m.push_notification_tokens == nil {
		m.push_notification_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.push_notification_tokens[ids[i]] = struct{}{}
	}
}

// ClearPushNotificationTokens clears the "push_notification_tokens" edge to the PushNotificationToken entity.
func (m *UserMutation) ClearPushNotificationTokens() {
	m.clearedpush_notification_tokens = true
}

// PushNotificationTokensCleared reports if the "push_notification_tokens" edge to the PushNotificationToken entity was cleared.
func (m *UserMutation) PushNotificationTokensCleared() bool {
	return m.clearedpush_notification_tokens
}

// RemovePushNotificationTokenIDs removes the "push_notification_tokens" edge to the PushNotificationToken entity by IDs.
func (m *UserMutation) RemovePushNotificationTokenIDs(ids ...uuid.UUID) {
	if m.removedpush_notification_tokens == nil {
		m.removedpush_notification_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.push_notification_tokens, ids[i])
		m.removedpush_notification_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPushNotificationTokens returns the removed IDs of the "push_notification_tokens" edge to the PushNotificationToken entity.
func (m *UserMutation) RemovedPushNotificationTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedpush_notification_tokens {
		ids = append(ids, id)
	}
	return
}

// PushNotificationTokensIDs returns the "push_notification_tokens" edge IDs in the mutation.
func (m *UserMutation) PushNotificationTokensIDs() (ids []uuid.UUID) {
	for id := range m.push_notification_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPushNotificationTokens resets all changes to the "push_notification_tokens" edge.
func (m *UserMutation) ResetPushNotificationTokens() {
	m.push_notification_tokens = nil
	m.clearedpush_notification_tokens = false
	m.removedpush_notification_tokens = nil
}

// AddFriendGroupIDs adds the "friend_groups" edge to the FriendGroup entity by ids.
func (m *UserMutation) AddFriendGroupIDs(ids ...uuid.UUID) {
	if m.friend_groups == nil {
		m.friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friend_groups[ids[i]] = struct{}{}
	}
}

// ClearFriendGroups clears the "friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) ClearFriendGroups() {
	m.clearedfriend_groups = true
}

// FriendGroupsCleared reports if the "friend_groups" edge to the FriendGroup entity was cleared.
func (m *UserMutation) FriendGroupsCleared() bool {
	return m.clearedfriend_groups
}

// RemoveFriendGroupIDs removes the "friend_groups" edge to the FriendGroup entity by IDs.
func (m *UserMutation) RemoveFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedfriend_groups == nil {
		m.removedfriend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friend_groups, ids[i])
		m.removedfriend_groups[ids[i]] = struct{}{}
	}
}

// RemovedFriendGroups returns the removed IDs of the "friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) RemovedFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedfriend_groups {
		ids = append(ids, id)
	}
	return
}

// FriendGroupsIDs returns the "friend_groups" edge IDs in the mutation.
func (m *UserMutation) FriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetFriendGroups resets all changes to the "friend_groups" edge.
func (m *UserMutation) ResetFriendGroups() {
	m.friend_groups = nil
	m.clearedfriend_groups = false
	m.removedfriend_groups = nil
}

// AddBelongingFriendGroupIDs adds the "belonging_friend_groups" edge to the FriendGroup entity by ids.
func (m *UserMutation) AddBelongingFriendGroupIDs(ids ...uuid.UUID) {
	if m.belonging_friend_groups == nil {
		m.belonging_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.belonging_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearBelongingFriendGroups clears the "belonging_friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) ClearBelongingFriendGroups() {
	m.clearedbelonging_friend_groups = true
}

// BelongingFriendGroupsCleared reports if the "belonging_friend_groups" edge to the FriendGroup entity was cleared.
func (m *UserMutation) BelongingFriendGroupsCleared() bool {
	return m.clearedbelonging_friend_groups
}

// RemoveBelongingFriendGroupIDs removes the "belonging_friend_groups" edge to the FriendGroup entity by IDs.
func (m *UserMutation) RemoveBelongingFriendGroupIDs(ids ...uuid.UUID) {
	if m.removedbelonging_friend_groups == nil {
		m.removedbelonging_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.belonging_friend_groups, ids[i])
		m.removedbelonging_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedBelongingFriendGroups returns the removed IDs of the "belonging_friend_groups" edge to the FriendGroup entity.
func (m *UserMutation) RemovedBelongingFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedbelonging_friend_groups {
		ids = append(ids, id)
	}
	return
}

// BelongingFriendGroupsIDs returns the "belonging_friend_groups" edge IDs in the mutation.
func (m *UserMutation) BelongingFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.belonging_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetBelongingFriendGroups resets all changes to the "belonging_friend_groups" edge.
func (m *UserMutation) ResetBelongingFriendGroups() {
	m.belonging_friend_groups = nil
	m.clearedbelonging_friend_groups = false
	m.removedbelonging_friend_groups = nil
}

// AddInvitationAcceptanceIDs adds the "invitation_acceptances" edge to the InvitationAcceptance entity by ids.
func (m *UserMutation) AddInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.invitation_acceptances == nil {
		m.invitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_acceptances[ids[i]] = struct{}{}
	}
}

// ClearInvitationAcceptances clears the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *UserMutation) ClearInvitationAcceptances() {
	m.clearedinvitation_acceptances = true
}

// InvitationAcceptancesCleared reports if the "invitation_acceptances" edge to the InvitationAcceptance entity was cleared.
func (m *UserMutation) InvitationAcceptancesCleared() bool {
	return m.clearedinvitation_acceptances
}

// RemoveInvitationAcceptanceIDs removes the "invitation_acceptances" edge to the InvitationAcceptance entity by IDs.
func (m *UserMutation) RemoveInvitationAcceptanceIDs(ids ...uuid.UUID) {
	if m.removedinvitation_acceptances == nil {
		m.removedinvitation_acceptances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_acceptances, ids[i])
		m.removedinvitation_acceptances[ids[i]] = struct{}{}
	}
}

// RemovedInvitationAcceptances returns the removed IDs of the "invitation_acceptances" edge to the InvitationAcceptance entity.
func (m *UserMutation) RemovedInvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// InvitationAcceptancesIDs returns the "invitation_acceptances" edge IDs in the mutation.
func (m *UserMutation) InvitationAcceptancesIDs() (ids []uuid.UUID) {
	for id := range m.invitation_acceptances {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationAcceptances resets all changes to the "invitation_acceptances" edge.
func (m *UserMutation) ResetInvitationAcceptances() {
	m.invitation_acceptances = nil
	m.clearedinvitation_acceptances = false
	m.removedinvitation_acceptances = nil
}

// AddInvitationDenialIDs adds the "invitation_denials" edge to the InvitationDenial entity by ids.
func (m *UserMutation) AddInvitationDenialIDs(ids ...uuid.UUID) {
	if m.invitation_denials == nil {
		m.invitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitation_denials[ids[i]] = struct{}{}
	}
}

// ClearInvitationDenials clears the "invitation_denials" edge to the InvitationDenial entity.
func (m *UserMutation) ClearInvitationDenials() {
	m.clearedinvitation_denials = true
}

// InvitationDenialsCleared reports if the "invitation_denials" edge to the InvitationDenial entity was cleared.
func (m *UserMutation) InvitationDenialsCleared() bool {
	return m.clearedinvitation_denials
}

// RemoveInvitationDenialIDs removes the "invitation_denials" edge to the InvitationDenial entity by IDs.
func (m *UserMutation) RemoveInvitationDenialIDs(ids ...uuid.UUID) {
	if m.removedinvitation_denials == nil {
		m.removedinvitation_denials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitation_denials, ids[i])
		m.removedinvitation_denials[ids[i]] = struct{}{}
	}
}

// RemovedInvitationDenials returns the removed IDs of the "invitation_denials" edge to the InvitationDenial entity.
func (m *UserMutation) RemovedInvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitation_denials {
		ids = append(ids, id)
	}
	return
}

// InvitationDenialsIDs returns the "invitation_denials" edge IDs in the mutation.
func (m *UserMutation) InvitationDenialsIDs() (ids []uuid.UUID) {
	for id := range m.invitation_denials {
		ids = append(ids, id)
	}
	return
}

// ResetInvitationDenials resets all changes to the "invitation_denials" edge.
func (m *UserMutation) ResetInvitationDenials() {
	m.invitation_denials = nil
	m.clearedinvitation_denials = false
	m.removedinvitation_denials = nil
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by ids.
func (m *UserMutation) AddFriendshipIDs(ids ...uuid.UUID) {
	if m.friendships == nil {
		m.friendships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.friendships[ids[i]] = struct{}{}
	}
}

// ClearFriendships clears the "friendships" edge to the Friendship entity.
func (m *UserMutation) ClearFriendships() {
	m.clearedfriendships = true
}

// FriendshipsCleared reports if the "friendships" edge to the Friendship entity was cleared.
func (m *UserMutation) FriendshipsCleared() bool {
	return m.clearedfriendships
}

// RemoveFriendshipIDs removes the "friendships" edge to the Friendship entity by IDs.
func (m *UserMutation) RemoveFriendshipIDs(ids ...uuid.UUID) {
	if m.removedfriendships == nil {
		m.removedfriendships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.friendships, ids[i])
		m.removedfriendships[ids[i]] = struct{}{}
	}
}

// RemovedFriendships returns the removed IDs of the "friendships" edge to the Friendship entity.
func (m *UserMutation) RemovedFriendshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedfriendships {
		ids = append(ids, id)
	}
	return
}

// FriendshipsIDs returns the "friendships" edge IDs in the mutation.
func (m *UserMutation) FriendshipsIDs() (ids []uuid.UUID) {
	for id := range m.friendships {
		ids = append(ids, id)
	}
	return
}

// ResetFriendships resets all changes to the "friendships" edge.
func (m *UserMutation) ResetFriendships() {
	m.friendships = nil
	m.clearedfriendships = false
	m.removedfriendships = nil
}

// AddUserFriendGroupIDs adds the "user_friend_groups" edge to the UserFriendGroup entity by ids.
func (m *UserMutation) AddUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.user_friend_groups == nil {
		m.user_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_friend_groups[ids[i]] = struct{}{}
	}
}

// ClearUserFriendGroups clears the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *UserMutation) ClearUserFriendGroups() {
	m.cleareduser_friend_groups = true
}

// UserFriendGroupsCleared reports if the "user_friend_groups" edge to the UserFriendGroup entity was cleared.
func (m *UserMutation) UserFriendGroupsCleared() bool {
	return m.cleareduser_friend_groups
}

// RemoveUserFriendGroupIDs removes the "user_friend_groups" edge to the UserFriendGroup entity by IDs.
func (m *UserMutation) RemoveUserFriendGroupIDs(ids ...uuid.UUID) {
	if m.removeduser_friend_groups == nil {
		m.removeduser_friend_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_friend_groups, ids[i])
		m.removeduser_friend_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserFriendGroups returns the removed IDs of the "user_friend_groups" edge to the UserFriendGroup entity.
func (m *UserMutation) RemovedUserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_friend_groups {
		ids = append(ids, id)
	}
	return
}

// UserFriendGroupsIDs returns the "user_friend_groups" edge IDs in the mutation.
func (m *UserMutation) UserFriendGroupsIDs() (ids []uuid.UUID) {
	for id := range m.user_friend_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserFriendGroups resets all changes to the "user_friend_groups" edge.
func (m *UserMutation) ResetUserFriendGroups() {
	m.user_friend_groups = nil
	m.cleareduser_friend_groups = false
	m.removeduser_friend_groups = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.account != nil {
		fields = append(fields, user.FieldAccountID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAccountID:
		return m.AccountID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAccountID:
		return m.OldAccountID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAccountID:
		m.ResetAccountID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.account != nil {
		edges = append(edges, user.EdgeAccount)
	}
	if m.user_profile != nil {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.friend_users != nil {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.push_notification_tokens != nil {
		edges = append(edges, user.EdgePushNotificationTokens)
	}
	if m.friend_groups != nil {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.belonging_friend_groups != nil {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.invitation_acceptances != nil {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.invitation_denials != nil {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.friendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.user_friend_groups != nil {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserProfile:
		if id := m.user_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.friend_users))
		for id := range m.friend_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePushNotificationTokens:
		ids := make([]ent.Value, 0, len(m.push_notification_tokens))
		for id := range m.push_notification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendGroups:
		ids := make([]ent.Value, 0, len(m.friend_groups))
		for id := range m.friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongingFriendGroups:
		ids := make([]ent.Value, 0, len(m.belonging_friend_groups))
		for id := range m.belonging_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.invitation_acceptances))
		for id := range m.invitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.invitation_denials))
		for id := range m.invitation_denials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.friendships))
		for id := range m.friendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.user_friend_groups))
		for id := range m.user_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedfriend_users != nil {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.removedpush_notification_tokens != nil {
		edges = append(edges, user.EdgePushNotificationTokens)
	}
	if m.removedfriend_groups != nil {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.removedbelonging_friend_groups != nil {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.removedinvitation_acceptances != nil {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.removedinvitation_denials != nil {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.removedfriendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.removeduser_friend_groups != nil {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFriendUsers:
		ids := make([]ent.Value, 0, len(m.removedfriend_users))
		for id := range m.removedfriend_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePushNotificationTokens:
		ids := make([]ent.Value, 0, len(m.removedpush_notification_tokens))
		for id := range m.removedpush_notification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedfriend_groups))
		for id := range m.removedfriend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBelongingFriendGroups:
		ids := make([]ent.Value, 0, len(m.removedbelonging_friend_groups))
		for id := range m.removedbelonging_friend_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationAcceptances:
		ids := make([]ent.Value, 0, len(m.removedinvitation_acceptances))
		for id := range m.removedinvitation_acceptances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitationDenials:
		ids := make([]ent.Value, 0, len(m.removedinvitation_denials))
		for id := range m.removedinvitation_denials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.removedfriendships))
		for id := range m.removedfriendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserFriendGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_friend_groups))
		for id := range m.removeduser_friend_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedaccount {
		edges = append(edges, user.EdgeAccount)
	}
	if m.cleareduser_profile {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.clearedfriend_users {
		edges = append(edges, user.EdgeFriendUsers)
	}
	if m.clearedpush_notification_tokens {
		edges = append(edges, user.EdgePushNotificationTokens)
	}
	if m.clearedfriend_groups {
		edges = append(edges, user.EdgeFriendGroups)
	}
	if m.clearedbelonging_friend_groups {
		edges = append(edges, user.EdgeBelongingFriendGroups)
	}
	if m.clearedinvitation_acceptances {
		edges = append(edges, user.EdgeInvitationAcceptances)
	}
	if m.clearedinvitation_denials {
		edges = append(edges, user.EdgeInvitationDenials)
	}
	if m.clearedfriendships {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.cleareduser_friend_groups {
		edges = append(edges, user.EdgeUserFriendGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccount:
		return m.clearedaccount
	case user.EdgeUserProfile:
		return m.cleareduser_profile
	case user.EdgeFriendUsers:
		return m.clearedfriend_users
	case user.EdgePushNotificationTokens:
		return m.clearedpush_notification_tokens
	case user.EdgeFriendGroups:
		return m.clearedfriend_groups
	case user.EdgeBelongingFriendGroups:
		return m.clearedbelonging_friend_groups
	case user.EdgeInvitationAcceptances:
		return m.clearedinvitation_acceptances
	case user.EdgeInvitationDenials:
		return m.clearedinvitation_denials
	case user.EdgeFriendships:
		return m.clearedfriendships
	case user.EdgeUserFriendGroups:
		return m.cleareduser_friend_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeAccount:
		m.ClearAccount()
		return nil
	case user.EdgeUserProfile:
		m.ClearUserProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccount:
		m.ResetAccount()
		return nil
	case user.EdgeUserProfile:
		m.ResetUserProfile()
		return nil
	case user.EdgeFriendUsers:
		m.ResetFriendUsers()
		return nil
	case user.EdgePushNotificationTokens:
		m.ResetPushNotificationTokens()
		return nil
	case user.EdgeFriendGroups:
		m.ResetFriendGroups()
		return nil
	case user.EdgeBelongingFriendGroups:
		m.ResetBelongingFriendGroups()
		return nil
	case user.EdgeInvitationAcceptances:
		m.ResetInvitationAcceptances()
		return nil
	case user.EdgeInvitationDenials:
		m.ResetInvitationDenials()
		return nil
	case user.EdgeFriendships:
		m.ResetFriendships()
		return nil
	case user.EdgeUserFriendGroups:
		m.ResetUserFriendGroups()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBlockMutation represents an operation that mutates the UserBlock nodes in the graph.
type UserBlockMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	block_user        *uuid.UUID
	clearedblock_user bool
	done              bool
	oldValue          func(context.Context) (*UserBlock, error)
	predicates        []predicate.UserBlock
}

var _ ent.Mutation = (*UserBlockMutation)(nil)

// userblockOption allows management of the mutation configuration using functional options.
type userblockOption func(*UserBlockMutation)

// newUserBlockMutation creates new mutation for the UserBlock entity.
func newUserBlockMutation(c config, op Op, opts ...userblockOption) *UserBlockMutation {
	m := &UserBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBlockID sets the ID field of the mutation.
func withUserBlockID(id uuid.UUID) userblockOption {
	return func(m *UserBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBlock
		)
		m.oldValue = func(ctx context.Context) (*UserBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBlock sets the old UserBlock of the mutation.
func withUserBlock(node *UserBlock) userblockOption {
	return func(m *UserBlockMutation) {
		m.oldValue = func(context.Context) (*UserBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBlock entities.
func (m *UserBlockMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBlockMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBlockMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserBlockMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBlockMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBlockMutation) ResetUserID() {
	m.user = nil
}

// SetBlockUserID sets the "block_user_id" field.
func (m *UserBlockMutation) SetBlockUserID(u uuid.UUID) {
	m.block_user = &u
}

// BlockUserID returns the value of the "block_user_id" field in the mutation.
func (m *UserBlockMutation) BlockUserID() (r uuid.UUID, exists bool) {
	v := m.block_user
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockUserID returns the old "block_user_id" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldBlockUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockUserID: %w", err)
	}
	return oldValue.BlockUserID, nil
}

// ResetBlockUserID resets all changes to the "block_user_id" field.
func (m *UserBlockMutation) ResetBlockUserID() {
	m.block_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBlockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBlockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBlockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBlockMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBlockMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBlockMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBlockMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearBlockUser clears the "block_user" edge to the User entity.
func (m *UserBlockMutation) ClearBlockUser() {
	m.clearedblock_user = true
}

// BlockUserCleared reports if the "block_user" edge to the User entity was cleared.
func (m *UserBlockMutation) BlockUserCleared() bool {
	return m.clearedblock_user
}

// BlockUserIDs returns the "block_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockUserID instead. It exists only for internal usage by the builders.
func (m *UserBlockMutation) BlockUserIDs() (ids []uuid.UUID) {
	if id := m.block_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockUser resets all changes to the "block_user" edge.
func (m *UserBlockMutation) ResetBlockUser() {
	m.block_user = nil
	m.clearedblock_user = false
}

// Where appends a list predicates to the UserBlockMutation builder.
func (m *UserBlockMutation) Where(ps ...predicate.UserBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBlock).
func (m *UserBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBlockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userblock.FieldUserID)
	}
	if m.block_user != nil {
		fields = append(fields, userblock.FieldBlockUserID)
	}
	if m.created_at != nil {
		fields = append(fields, userblock.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userblock.FieldUserID:
		return m.UserID()
	case userblock.FieldBlockUserID:
		return m.BlockUserID()
	case userblock.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userblock.FieldUserID:
		return m.OldUserID(ctx)
	case userblock.FieldBlockUserID:
		return m.OldBlockUserID(ctx)
	case userblock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userblock.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userblock.FieldBlockUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockUserID(v)
		return nil
	case userblock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBlockMutation) ResetField(name string) error {
	switch name {
	case userblock.FieldUserID:
		m.ResetUserID()
		return nil
	case userblock.FieldBlockUserID:
		m.ResetBlockUserID()
		return nil
	case userblock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userblock.EdgeUser)
	}
	if m.block_user != nil {
		edges = append(edges, userblock.EdgeBlockUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userblock.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userblock.EdgeBlockUser:
		if id := m.block_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userblock.EdgeUser)
	}
	if m.clearedblock_user {
		edges = append(edges, userblock.EdgeBlockUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case userblock.EdgeUser:
		return m.cleareduser
	case userblock.EdgeBlockUser:
		return m.clearedblock_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBlockMutation) ClearEdge(name string) error {
	switch name {
	case userblock.EdgeUser:
		m.ClearUser()
		return nil
	case userblock.EdgeBlockUser:
		m.ClearBlockUser()
		return nil
	}
	return fmt.Errorf("unknown UserBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBlockMutation) ResetEdge(name string) error {
	switch name {
	case userblock.EdgeUser:
		m.ResetUser()
		return nil
	case userblock.EdgeBlockUser:
		m.ResetBlockUser()
		return nil
	}
	return fmt.Errorf("unknown UserBlock edge %s", name)
}

// UserFriendGroupMutation represents an operation that mutates the UserFriendGroup nodes in the graph.
type UserFriendGroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	clearedFields       map[string]struct{}
	friend_group        *uuid.UUID
	clearedfriend_group bool
	user                *uuid.UUID
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*UserFriendGroup, error)
	predicates          []predicate.UserFriendGroup
}

var _ ent.Mutation = (*UserFriendGroupMutation)(nil)

// userfriendgroupOption allows management of the mutation configuration using functional options.
type userfriendgroupOption func(*UserFriendGroupMutation)

// newUserFriendGroupMutation creates new mutation for the UserFriendGroup entity.
func newUserFriendGroupMutation(c config, op Op, opts ...userfriendgroupOption) *UserFriendGroupMutation {
	m := &UserFriendGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFriendGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFriendGroupID sets the ID field of the mutation.
func withUserFriendGroupID(id uuid.UUID) userfriendgroupOption {
	return func(m *UserFriendGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFriendGroup
		)
		m.oldValue = func(ctx context.Context) (*UserFriendGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFriendGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFriendGroup sets the old UserFriendGroup of the mutation.
func withUserFriendGroup(node *UserFriendGroup) userfriendgroupOption {
	return func(m *UserFriendGroupMutation) {
		m.oldValue = func(context.Context) (*UserFriendGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFriendGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFriendGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFriendGroup entities.
func (m *UserFriendGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFriendGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFriendGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFriendGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFriendGroupID sets the "friend_group_id" field.
func (m *UserFriendGroupMutation) SetFriendGroupID(u uuid.UUID) {
	m.friend_group = &u
}

// FriendGroupID returns the value of the "friend_group_id" field in the mutation.
func (m *UserFriendGroupMutation) FriendGroupID() (r uuid.UUID, exists bool) {
	v := m.friend_group
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendGroupID returns the old "friend_group_id" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldFriendGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendGroupID: %w", err)
	}
	return oldValue.FriendGroupID, nil
}

// ResetFriendGroupID resets all changes to the "friend_group_id" field.
func (m *UserFriendGroupMutation) ResetFriendGroupID() {
	m.friend_group = nil
}

// SetUserID sets the "user_id" field.
func (m *UserFriendGroupMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFriendGroupMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFriendGroupMutation) ResetUserID() {
	m.user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFriendGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFriendGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFriendGroup entity.
// If the UserFriendGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFriendGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFriendGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFriendGroup clears the "friend_group" edge to the FriendGroup entity.
func (m *UserFriendGroupMutation) ClearFriendGroup() {
	m.clearedfriend_group = true
}

// FriendGroupCleared reports if the "friend_group" edge to the FriendGroup entity was cleared.
func (m *UserFriendGroupMutation) FriendGroupCleared() bool {
	return m.clearedfriend_group
}

// FriendGroupIDs returns the "friend_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendGroupID instead. It exists only for internal usage by the builders.
func (m *UserFriendGroupMutation) FriendGroupIDs() (ids []uuid.UUID) {
	if id := m.friend_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriendGroup resets all changes to the "friend_group" edge.
func (m *UserFriendGroupMutation) ResetFriendGroup() {
	m.friend_group = nil
	m.clearedfriend_group = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFriendGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFriendGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFriendGroupMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFriendGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserFriendGroupMutation builder.
func (m *UserFriendGroupMutation) Where(ps ...predicate.UserFriendGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFriendGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFriendGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFriendGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFriendGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFriendGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFriendGroup).
func (m *UserFriendGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFriendGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.friend_group != nil {
		fields = append(fields, userfriendgroup.FieldFriendGroupID)
	}
	if m.user != nil {
		fields = append(fields, userfriendgroup.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, userfriendgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFriendGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		return m.FriendGroupID()
	case userfriendgroup.FieldUserID:
		return m.UserID()
	case userfriendgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFriendGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		return m.OldFriendGroupID(ctx)
	case userfriendgroup.FieldUserID:
		return m.OldUserID(ctx)
	case userfriendgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFriendGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendGroupID(v)
		return nil
	case userfriendgroup.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfriendgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFriendGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFriendGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFriendGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFriendGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFriendGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFriendGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFriendGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFriendGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFriendGroupMutation) ResetField(name string) error {
	switch name {
	case userfriendgroup.FieldFriendGroupID:
		m.ResetFriendGroupID()
		return nil
	case userfriendgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case userfriendgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFriendGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.friend_group != nil {
		edges = append(edges, userfriendgroup.EdgeFriendGroup)
	}
	if m.user != nil {
		edges = append(edges, userfriendgroup.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFriendGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		if id := m.friend_group; id != nil {
			return []ent.Value{*id}
		}
	case userfriendgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFriendGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFriendGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFriendGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfriend_group {
		edges = append(edges, userfriendgroup.EdgeFriendGroup)
	}
	if m.cleareduser {
		edges = append(edges, userfriendgroup.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFriendGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		return m.clearedfriend_group
	case userfriendgroup.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFriendGroupMutation) ClearEdge(name string) error {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		m.ClearFriendGroup()
		return nil
	case userfriendgroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFriendGroupMutation) ResetEdge(name string) error {
	switch name {
	case userfriendgroup.EdgeFriendGroup:
		m.ResetFriendGroup()
		return nil
	case userfriendgroup.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserFriendGroup edge %s", name)
}

// UserLocationMutation represents an operation that mutates the UserLocation nodes in the graph.
type UserLocationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	coordinate    **pgutil.GeoPoint
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserLocation, error)
	predicates    []predicate.UserLocation
}

var _ ent.Mutation = (*UserLocationMutation)(nil)

// userlocationOption allows management of the mutation configuration using functional options.
type userlocationOption func(*UserLocationMutation)

// newUserLocationMutation creates new mutation for the UserLocation entity.
func newUserLocationMutation(c config, op Op, opts ...userlocationOption) *UserLocationMutation {
	m := &UserLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLocationID sets the ID field of the mutation.
func withUserLocationID(id uuid.UUID) userlocationOption {
	return func(m *UserLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLocation
		)
		m.oldValue = func(ctx context.Context) (*UserLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLocation sets the old UserLocation of the mutation.
func withUserLocation(node *UserLocation) userlocationOption {
	return func(m *UserLocationMutation) {
		m.oldValue = func(context.Context) (*UserLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLocation entities.
func (m *UserLocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserLocationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLocationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLocationMutation) ResetUserID() {
	m.user = nil
}

// SetCoordinate sets the "coordinate" field.
func (m *UserLocationMutation) SetCoordinate(pp *pgutil.GeoPoint) {
	m.coordinate = &pp
}

// Coordinate returns the value of the "coordinate" field in the mutation.
func (m *UserLocationMutation) Coordinate() (r *pgutil.GeoPoint, exists bool) {
	v := m.coordinate
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinate returns the old "coordinate" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldCoordinate(ctx context.Context) (v *pgutil.GeoPoint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinate: %w", err)
	}
	return oldValue.Coordinate, nil
}

// ResetCoordinate resets all changes to the "coordinate" field.
func (m *UserLocationMutation) ResetCoordinate() {
	m.coordinate = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLocation entity.
// If the UserLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLocationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLocationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLocationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLocationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserLocationMutation builder.
func (m *UserLocationMutation) Where(ps ...predicate.UserLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLocation).
func (m *UserLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLocationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userlocation.FieldUserID)
	}
	if m.coordinate != nil {
		fields = append(fields, userlocation.FieldCoordinate)
	}
	if m.updated_at != nil {
		fields = append(fields, userlocation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlocation.FieldUserID:
		return m.UserID()
	case userlocation.FieldCoordinate:
		return m.Coordinate()
	case userlocation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlocation.FieldUserID:
		return m.OldUserID(ctx)
	case userlocation.FieldCoordinate:
		return m.OldCoordinate(ctx)
	case userlocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlocation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userlocation.FieldCoordinate:
		v, ok := value.(*pgutil.GeoPoint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinate(v)
		return nil
	case userlocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLocationMutation) ResetField(name string) error {
	switch name {
	case userlocation.FieldUserID:
		m.ResetUserID()
		return nil
	case userlocation.FieldCoordinate:
		m.ResetCoordinate()
		return nil
	case userlocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userlocation.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlocation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userlocation.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case userlocation.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLocationMutation) ClearEdge(name string) error {
	switch name {
	case userlocation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLocationMutation) ResetEdge(name string) error {
	switch name {
	case userlocation.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLocation edge %s", name)
}

// UserMuteMutation represents an operation that mutates the UserMute nodes in the graph.
type UserMuteMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	mute_user        *uuid.UUID
	clearedmute_user bool
	done             bool
	oldValue         func(context.Context) (*UserMute, error)
	predicates       []predicate.UserMute
}

var _ ent.Mutation = (*UserMuteMutation)(nil)

// usermuteOption allows management of the mutation configuration using functional options.
type usermuteOption func(*UserMuteMutation)

// newUserMuteMutation creates new mutation for the UserMute entity.
func newUserMuteMutation(c config, op Op, opts ...usermuteOption) *UserMuteMutation {
	m := &UserMuteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserMute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserMuteID sets the ID field of the mutation.
func withUserMuteID(id uuid.UUID) usermuteOption {
	return func(m *UserMuteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserMute
		)
		m.oldValue = func(ctx context.Context) (*UserMute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserMute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserMute sets the old UserMute of the mutation.
func withUserMute(node *UserMute) usermuteOption {
	return func(m *UserMuteMutation) {
		m.oldValue = func(context.Context) (*UserMute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMuteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMuteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserMute entities.
func (m *UserMuteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMuteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMuteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserMute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserMuteMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserMuteMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserMuteMutation) ResetUserID() {
	m.user = nil
}

// SetMuteUserID sets the "mute_user_id" field.
func (m *UserMuteMutation) SetMuteUserID(u uuid.UUID) {
	m.mute_user = &u
}

// MuteUserID returns the value of the "mute_user_id" field in the mutation.
func (m *UserMuteMutation) MuteUserID() (r uuid.UUID, exists bool) {
	v := m.mute_user
	if v == nil {
		return
	}
	return *v, true
}

// OldMuteUserID returns the old "mute_user_id" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldMuteUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMuteUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMuteUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMuteUserID: %w", err)
	}
	return oldValue.MuteUserID, nil
}

// ResetMuteUserID resets all changes to the "mute_user_id" field.
func (m *UserMuteMutation) ResetMuteUserID() {
	m.mute_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMuteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMuteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserMute entity.
// If the UserMute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMuteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMuteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserMuteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserMuteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserMuteMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserMuteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMuteUser clears the "mute_user" edge to the User entity.
func (m *UserMuteMutation) ClearMuteUser() {
	m.clearedmute_user = true
}

// MuteUserCleared reports if the "mute_user" edge to the User entity was cleared.
func (m *UserMuteMutation) MuteUserCleared() bool {
	return m.clearedmute_user
}

// MuteUserIDs returns the "mute_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MuteUserID instead. It exists only for internal usage by the builders.
func (m *UserMuteMutation) MuteUserIDs() (ids []uuid.UUID) {
	if id := m.mute_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMuteUser resets all changes to the "mute_user" edge.
func (m *UserMuteMutation) ResetMuteUser() {
	m.mute_user = nil
	m.clearedmute_user = false
}

// Where appends a list predicates to the UserMuteMutation builder.
func (m *UserMuteMutation) Where(ps ...predicate.UserMute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMuteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMuteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserMute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMuteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMuteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserMute).
func (m *UserMuteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMuteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, usermute.FieldUserID)
	}
	if m.mute_user != nil {
		fields = append(fields, usermute.FieldMuteUserID)
	}
	if m.created_at != nil {
		fields = append(fields, usermute.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMuteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usermute.FieldUserID:
		return m.UserID()
	case usermute.FieldMuteUserID:
		return m.MuteUserID()
	case usermute.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMuteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usermute.FieldUserID:
		return m.OldUserID(ctx)
	case usermute.FieldMuteUserID:
		return m.OldMuteUserID(ctx)
	case usermute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserMute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMuteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usermute.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usermute.FieldMuteUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMuteUserID(v)
		return nil
	case usermute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserMute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMuteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMuteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMuteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserMute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMuteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMuteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMuteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserMute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMuteMutation) ResetField(name string) error {
	switch name {
	case usermute.FieldUserID:
		m.ResetUserID()
		return nil
	case usermute.FieldMuteUserID:
		m.ResetMuteUserID()
		return nil
	case usermute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserMute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMuteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usermute.EdgeUser)
	}
	if m.mute_user != nil {
		edges = append(edges, usermute.EdgeMuteUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMuteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usermute.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usermute.EdgeMuteUser:
		if id := m.mute_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMuteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMuteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMuteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usermute.EdgeUser)
	}
	if m.clearedmute_user {
		edges = append(edges, usermute.EdgeMuteUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMuteMutation) EdgeCleared(name string) bool {
	switch name {
	case usermute.EdgeUser:
		return m.cleareduser
	case usermute.EdgeMuteUser:
		return m.clearedmute_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMuteMutation) ClearEdge(name string) error {
	switch name {
	case usermute.EdgeUser:
		m.ClearUser()
		return nil
	case usermute.EdgeMuteUser:
		m.ClearMuteUser()
		return nil
	}
	return fmt.Errorf("unknown UserMute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMuteMutation) ResetEdge(name string) error {
	switch name {
	case usermute.EdgeUser:
		m.ResetUser()
		return nil
	case usermute.EdgeMuteUser:
		m.ResetMuteUser()
		return nil
	}
	return fmt.Errorf("unknown UserMute edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	screen_id     *string
	nickname      *string
	avatar_url    *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserProfile, error)
	predicates    []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id uuid.UUID) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProfile entities.
func (m *UserProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserProfileMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProfileMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProfileMutation) ResetUserID() {
	m.user = nil
}

// SetScreenID sets the "screen_id" field.
func (m *UserProfileMutation) SetScreenID(s string) {
	m.screen_id = &s
}

// ScreenID returns the value of the "screen_id" field in the mutation.
func (m *UserProfileMutation) ScreenID() (r string, exists bool) {
	v := m.screen_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScreenID returns the old "screen_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldScreenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScreenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScreenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScreenID: %w", err)
	}
	return oldValue.ScreenID, nil
}

// ResetScreenID resets all changes to the "screen_id" field.
func (m *UserProfileMutation) ResetScreenID() {
	m.screen_id = nil
}

// SetNickname sets the "nickname" field.
func (m *UserProfileMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserProfileMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserProfileMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserProfileMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserProfileMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserProfileMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, userprofile.FieldUserID)
	}
	if m.screen_id != nil {
		fields = append(fields, userprofile.FieldScreenID)
	}
	if m.nickname != nil {
		fields = append(fields, userprofile.FieldNickname)
	}
	if m.avatar_url != nil {
		fields = append(fields, userprofile.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, userprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userprofile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldUserID:
		return m.UserID()
	case userprofile.FieldScreenID:
		return m.ScreenID()
	case userprofile.FieldNickname:
		return m.Nickname()
	case userprofile.FieldAvatarURL:
		return m.AvatarURL()
	case userprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userprofile.FieldScreenID:
		return m.OldScreenID(ctx)
	case userprofile.FieldNickname:
		return m.OldNickname(ctx)
	case userprofile.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case userprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userprofile.FieldScreenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScreenID(v)
		return nil
	case userprofile.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case userprofile.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case userprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userprofile.FieldScreenID:
		m.ResetScreenID()
		return nil
	case userprofile.FieldNickname:
		m.ResetNickname()
		return nil
	case userprofile.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case userprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
