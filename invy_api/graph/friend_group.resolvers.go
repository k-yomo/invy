package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"

	cerrors "github.com/cockroachdb/errors"
	"github.com/google/uuid"
	"github.com/k-yomo/invy/invy_api/ent"
	"github.com/k-yomo/invy/invy_api/ent/friendgroup"
	"github.com/k-yomo/invy/invy_api/ent/user"
	"github.com/k-yomo/invy/invy_api/ent/userfriendgroup"
	"github.com/k-yomo/invy/invy_api/graph/conv"
	"github.com/k-yomo/invy/invy_api/graph/gqlgen"
	"github.com/k-yomo/invy/invy_api/graph/gqlmodel"
	"github.com/k-yomo/invy/invy_api/internal/auth"
	"github.com/k-yomo/invy/pkg/convutil"
)

// FriendUsers is the resolver for the friendUsers field.
func (r *friendGroupResolver) FriendUsers(ctx context.Context, obj *gqlmodel.FriendGroup) ([]*gqlmodel.User, error) {
	dbFriendUsersInGroup, err := r.DB.FriendGroup.Query().
		Where(friendgroup.ID(obj.ID)).
		QueryFriendUsers().
		Where(user.StatusEQ(user.StatusActive)).
		QueryUserProfile().
		All(ctx)
	if err != nil {
		return nil, cerrors.Wrap(err, "query friend users in the group")
	}
	return convutil.ConvertToList(dbFriendUsersInGroup, conv.ConvertFromDBUserProfile), nil
}

// CreateFriendGroup is the resolver for the createFriendGroup field.
func (r *mutationResolver) CreateFriendGroup(ctx context.Context, input gqlmodel.CreateFriendGroupInput) (*gqlmodel.CreateFriendGroupPayload, error) {
	authUserID := auth.GetCurrentUserID(ctx)
	var dbFriendGroup *ent.FriendGroup
	err := ent.RunInTx(ctx, r.DB, func(tx *ent.Tx) error {
		var err error
		dbFriendGroup, err = tx.FriendGroup.Create().
			SetName(input.Name).
			SetUserID(authUserID).
			SetTotalCount(len(input.FriendUserIds)).
			Save(ctx)
		if err != nil {
			return cerrors.Wrap(err, "create friend group")
		}

		dbUserFriendGroupCreates := make([]*ent.UserFriendGroupCreate, 0, len(input.FriendUserIds))
		for _, friendUserID := range input.FriendUserIds {
			userFriendGroupCreate := tx.UserFriendGroup.Create().
				SetUserID(friendUserID).
				SetFriendGroupID(dbFriendGroup.ID)
			dbUserFriendGroupCreates = append(dbUserFriendGroupCreates, userFriendGroupCreate)
		}
		if err := tx.UserFriendGroup.CreateBulk(dbUserFriendGroupCreates...).Exec(ctx); err != nil {
			return cerrors.Wrap(err, "create user friend group in bulk")
		}
		return nil
	})
	if err != nil {
		return nil, cerrors.Wrap(err, "ent run transaction")
	}
	return &gqlmodel.CreateFriendGroupPayload{FriendGroup: conv.ConvertFromDBFriendGroup(dbFriendGroup)}, nil
}

// UpdateFriendGroup is the resolver for the updateFriendGroup field.
func (r *mutationResolver) UpdateFriendGroup(ctx context.Context, input gqlmodel.UpdateFriendGroupInput) (*gqlmodel.UpdateFriendGroupPayload, error) {
	authUserID := auth.GetCurrentUserID(ctx)
	err := ent.RunInTx(ctx, r.DB, func(tx *ent.Tx) error {
		updatedNum, err := tx.FriendGroup.Update().
			Where(friendgroup.ID(input.ID), friendgroup.UserID(authUserID)).
			SetName(input.Name).
			SetTotalCount(len(input.FriendUserIds)).
			Save(ctx)
		if err != nil {
			return cerrors.Wrap(err, "update friend group")
		}
		// no update means the group does not exist or not belonging to the logged in user
		if updatedNum == 0 {
			return nil
		}
		// FIXME: remove -diff & add +diff would be better than clear then add
		_, err = tx.UserFriendGroup.Delete().
			Where(userfriendgroup.FriendGroupID(input.ID)).
			Exec(ctx)
		if err != nil {
			return cerrors.Wrap(err, "delete user friend group")
		}

		dbUserFriendGroupCreates := make([]*ent.UserFriendGroupCreate, 0, len(input.FriendUserIds))
		for _, friendUserID := range input.FriendUserIds {
			userFriendGroupCreate := tx.UserFriendGroup.Create().
				SetUserID(friendUserID).
				SetFriendGroupID(input.ID)
			dbUserFriendGroupCreates = append(dbUserFriendGroupCreates, userFriendGroupCreate)
		}
		if err := tx.UserFriendGroup.CreateBulk(dbUserFriendGroupCreates...).Exec(ctx); err != nil {
			return cerrors.Wrap(err, "create user friend group in bulk")
		}
		return nil
	})
	if err != nil {
		return nil, cerrors.Wrap(err, "ent run transaction")
	}

	dbFriendGroup, err := r.DB.FriendGroup.Query().
		Where(friendgroup.ID(input.ID), friendgroup.UserID(authUserID)).
		Only(ctx)
	if err != nil {
		return nil, cerrors.Wrap(err, "get friend group")
	}
	return &gqlmodel.UpdateFriendGroupPayload{FriendGroup: conv.ConvertFromDBFriendGroup(dbFriendGroup)}, nil
}

// DeleteFriendGroup is the resolver for the deleteFriendGroup field.
func (r *mutationResolver) DeleteFriendGroup(ctx context.Context, friendGroupID uuid.UUID) (*gqlmodel.DeleteFriendGroupPayload, error) {
	authUserID := auth.GetCurrentUserID(ctx)
	_, err := r.DB.FriendGroup.Delete().
		Where(friendgroup.ID(friendGroupID), friendgroup.UserID(authUserID)).
		Exec(ctx)
	if err != nil {
		return nil, cerrors.Wrap(err, "delete friend group")
	}
	return &gqlmodel.DeleteFriendGroupPayload{DeletedFriendGroupID: friendGroupID}, nil
}

// FriendGroup returns gqlgen.FriendGroupResolver implementation.
func (r *Resolver) FriendGroup() gqlgen.FriendGroupResolver { return &friendGroupResolver{r} }

type friendGroupResolver struct{ *Resolver }
