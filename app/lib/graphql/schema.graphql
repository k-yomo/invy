schema { 
  query: Query 
  mutation: Mutation   
}

directive @authRequired on FIELD_DEFINITION

directive @constraint(min: Int, max: Int, pattern: String, format: ConstraintFormat) on INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type AcceptFriendshipRequestPayload {
  acceptedFriendshipRequestId: UUID!
}

type AcceptInvitationPayload {
  invitation: Invitation!
}

type ActivateInvitationPayload {
  invitation: Invitation!
}

type BlockUserPayload {
  blockedUserId: UUID!
}

type CancelFriendshipRequestPayload {
  canceledFriendshipRequestId: UUID!
}

type ChatMessage implements Node {
  id: UUID!
  chatRoomId: UUID!
  userId: UUID!
  kind: ChatMessageKind!
  body: ChatMessageBody!
  createdAt: Time!
}

union ChatMessageBody = ChatMessageBodyText | ChatMessageBodyImage

type ChatMessageBodyImage {
  url: String!
}

type ChatMessageBodyText {
  text: String!
}

enum ChatMessageKind {
  TEXT
  IMAGE
}

type ChatRoom implements Node {
  id: UUID!
  participantUserIds: [UUID!]!
  participants: [ChatRoomParticipant!]!
  createdAt: Time!
}

type ChatRoomParticipant {
  userId: UUID!
  lastReadAt: Time!
}

type CloseInvitationPayload {
  invitation: Invitation!
}

enum ConstraintFormat {
  EMAIL
  URL
}

type Coordinate {
  latitude: Float!
  longitude: Float!
}

input CreateFriendGroupInput {
  name: String!
  friendUserIds: [UUID!]!
}

type CreateFriendGroupPayload {
  friendGroup: FriendGroup!
}

input CreateUserInput {
  nickname: String!
  avatarUrl: String
}

type CreateUserPayload {
  viewer: Viewer!
}

scalar Cursor

type DeleteAccountPayload {
  deletedAccountId: UUID!
}

type DeleteFriendGroupPayload {
  deletedFriendGroupId: UUID!
}

type DeleteInvitationAwaitingPayload {
  deletedInvitationAwaitingId: UUID!
}

type DeleteInvitationPayload {
  deletedInvitationId: UUID!
}

type DenyFriendshipRequestPayload {
  deniedFriendshipRequestId: UUID!
}

type DenyInvitationPayload {
  invitation: Invitation!
}

enum ErrorCode {
  INVALID_ARGUMENT
  UNAUTHENTICATED
  FORBIDDEN
  NOT_FOUND
  ALREADY_EXISTS
  CONFLICT
  INTERNAL
}

type FriendGroup implements Node {
  id: UUID!
  userId: UUID!
  name: String!
  totalCount: Int!
  friendUsers: [User!]!
}

type FriendshipRequest implements Node {
  id: UUID!
  fromUserId: UUID!
  fromUser: User!
  toUserId: UUID!
  toUser: User!
  createdAt: Time!
}

type Invitation implements Node {
  id: UUID!
  status: InvitationStatus!
  userId: UUID!
  user: User!
  location: String!
  coordinate: Coordinate
  comment: String!
  startsAt: Time!
  expiresAt: Time!
  chatRoomId: UUID
  chatRoom: ChatRoom
  acceptedUsers: [User!]!
  isAccepted: Boolean!
}

type InvitationAwaiting implements Node {
  id: UUID!
  userId: UUID!
  user: User!
  startsAt: Time!
  endsAt: Time!
  comment: String!
}

enum InvitationStatus {
  ACTIVE
  CLOSED
}

type Mutation {
  signUp(input: SignUpInput!): SignUpPayload!
  signOut: SignOutPayload!
  deleteAccount: DeleteAccountPayload!
  createUser(input: CreateUserInput!): CreateUserPayload!
  switchUser(userId: UUID!): SwitchUserPayload!
  sendChatMessageText(input: SendChatMessageTextInput): SendChatMessageTextPayload!
  sendChatMessageImage(input: SendChatMessageImageInput): SendChatMessageImagePayload!
  updateChatLastReadAt(input: UpdateChatLastReadAtInput!): UpdateChatLastReadAtPayload!
  createFriendGroup(input: CreateFriendGroupInput!): CreateFriendGroupPayload!
  updateFriendGroup(input: UpdateFriendGroupInput!): UpdateFriendGroupPayload!
  deleteFriendGroup(friendGroupId: UUID!): DeleteFriendGroupPayload!
  sendInvitation(input: SendInvitationInput): SendInvitationPayload!
  closeInvitation(invitationId: UUID!): CloseInvitationPayload!
  activateInvitation(invitationId: UUID!): ActivateInvitationPayload!
  deleteInvitation(invitationId: UUID!): DeleteInvitationPayload!
  acceptInvitation(invitationId: UUID!): AcceptInvitationPayload!
  denyInvitation(invitationId: UUID!): DenyInvitationPayload!
  registerInvitationAwaiting(input: RegisterInvitationAwaitingInput!): RegisterInvitationAwaitingPayload!
  deleteInvitationAwaiting(invitationAwaitingId: UUID!): DeleteInvitationAwaitingPayload!
  registerPushNotificationToken(input: RegisterPushNotificationTokenInput): RegisterPushNotificationTokenPayload!
  updateLocation(latitude: Float!, longitude: Float!): UpdateLocationPayload!
  requestFriendship(friendUserId: UUID!): RequestFriendshipPayload!
  cancelFriendshipRequest(friendshipRequestId: UUID!): CancelFriendshipRequestPayload!
  acceptFriendshipRequest(friendshipRequestId: UUID!): AcceptFriendshipRequestPayload!
  denyFriendshipRequest(friendshipRequestId: UUID!): DenyFriendshipRequestPayload!
  muteUser(userId: UUID!): MuteUserPayload!
  unmuteUser(userId: UUID!): UnmuteUserPayload!
  blockUser(userId: UUID!): BlockUserPayload!
  unblockUser(userId: UUID!): UnblockUserPayload!
  updateAvatar(avatar: Upload!): UpdateAvatarPayload!
  updateNickname(nickname: String!): UpdateNicknamePayload!
  updateScreenId(screenId: String!): UpdateScreenIdPayload!
}

type MuteUserPayload {
  mutedUserId: UUID!
}

interface Node {
  id: UUID!
}

type PageInfo {
  startCursor: Cursor
  endCursor: Cursor
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

"""PushNotificationType is included in the push notification payload"""
enum PushNotificationType {
  FRIENDSHIP_REQUEST_RECEIVED
  FRIENDSHIP_REQUEST_ACCEPTED
  INVITATION_RECEIVED
  INVITATION_ACCEPTED
  INVITATION_DELETED
  INVITATION_AWAITING_RECEIVED
  CHAT_MESSAGE_RECEIVED
}

type Query {
  invitation(id: UUID!): Invitation!
  viewer: Viewer!
  user(userId: UUID!): User!

  """fetch user by screen id"""
  userByScreenId(screenId: String!): User!

  """It'll be empty when not friend"""
  userFriends(userId: UUID!, after: Cursor, first: Int, before: Cursor, last: Int): UserConnection!
}

input RegisterInvitationAwaitingInput {
  startsAt: Time!
  endsAt: Time!
  comment: String!
}

type RegisterInvitationAwaitingPayload {
  invitationAwaiting: InvitationAwaiting!
}

input RegisterPushNotificationTokenInput {
  deviceId: String!
  fcmToken: String!
}

type RegisterPushNotificationTokenPayload {
  registeredPushNotificationTokenId: UUID!
}

type RequestFriendshipPayload {
  friendShipRequest: FriendshipRequest!
}

input SendChatMessageImageInput {
  id: UUID!
  chatRoomId: UUID!
  image: Upload!
}

type SendChatMessageImagePayload {
  chatMessage: ChatMessage!
}

input SendChatMessageTextInput {
  id: UUID!
  chatRoomId: UUID!
  text: String!
}

type SendChatMessageTextPayload {
  chatMessage: ChatMessage!
}

input SendInvitationInput {
  targetFriendGroupIds: [UUID!]!
  targetFriendUserIds: [UUID!]!
  expiresAt: Time!
  startsAt: Time!
  location: String!
  latitude: Float
  longitude: Float
  comment: String!
}

type SendInvitationPayload {
  invitation: Invitation!
}

type SignOutPayload {
  signedOutUserId: UUID!
}

input SignUpInput {
  email: String
  nickname: String
  avatarUrl: String
}

type SignUpPayload {
  viewer: Viewer!
}

type SwitchUserPayload {
  viewer: Viewer!
}

scalar Time

type UnblockUserPayload {
  unblockedUserId: UUID!
}

type UnmuteUserPayload {
  unmutedUserId: UUID!
}

type UpdateAvatarPayload {
  viewer: Viewer!
}

input UpdateChatLastReadAtInput {
  chatRoomId: UUID!
  lastReadAt: Time!
}

type UpdateChatLastReadAtPayload {
  chatRoomId: UUID!
}

input UpdateFriendGroupInput {
  id: UUID!
  name: String!
  friendUserIds: [UUID!]!
}

type UpdateFriendGroupPayload {
  friendGroup: FriendGroup!
}

type UpdateLocationPayload {
  updatedUserLocationId: UUID!
}

type UpdateNicknamePayload {
  viewer: Viewer!
}

type UpdateScreenIdPayload {
  viewer: Viewer!
}

scalar Upload

"""
User is a public interface for a user
User MUST NOT have private information such as email
"""
type User implements Node {
  id: UUID!
  screenId: String!
  nickname: String!
  avatarUrl: String!
  isMuted: Boolean!
  isBlocked: Boolean!
  isFriend: Boolean!

  """
  This is an approximate distance in kilometer.
  It'll be null when not friend or the location tracking is not enabled by the user
  """
  distanceKm: Int
  isRequestingFriendship: Boolean!

  """It'll be empty when not friend"""
  invitationAwaitings: [InvitationAwaiting!]!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: Cursor!
}

scalar UUID

"""Currently logged in user"""
type Viewer implements Node {
  id: UUID!
  screenId: String!
  nickname: String!
  avatarUrl: String!
  friends(after: Cursor, first: Int, before: Cursor, last: Int): UserConnection!
  blockedFriends(after: Cursor, first: Int, before: Cursor, last: Int): UserConnection!

  """fetch friend ship requests need to be approved by the logged in user"""
  pendingFriendshipRequests: [FriendshipRequest!]!

  """fetch friend ship requests sent by the logged in user"""
  requestingFriendshipRequests: [FriendshipRequest!]!

  """
  fetch friend group
  Other user's group can't be fetched
  """
  friendGroup(friendGroupId: UUID!): FriendGroup!

  """fetch friend groups of the logged in user"""
  friendGroups: [FriendGroup!]!
  sentInvitations: [Invitation!]!
  pendingInvitations: [Invitation!]!
  acceptedInvitations: [Invitation!]!
  invitationAwaitings: [InvitationAwaiting!]!
}
